{"version":3,"file":"static/chunks/676-a5a2fc85194da7af.js","mappings":"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","sources":["webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/misc.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/logger.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/is.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/syncpromise.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/browser.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/object.js","webpack://_N_E/./node_modules/.pnpm/@sentry+hub@7.12.1/node_modules/@sentry/hub/esm/session.js","webpack://_N_E/./node_modules/.pnpm/@sentry+hub@7.12.1/node_modules/@sentry/hub/esm/scope.js","webpack://_N_E/./node_modules/.pnpm/@sentry+hub@7.12.1/node_modules/@sentry/hub/esm/hub.js","webpack://_N_E/./node_modules/.pnpm/@sentry+hub@7.12.1/node_modules/@sentry/hub/esm/exports.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/memo.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/stacktrace.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/normalize.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/url.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/requestdata.js","webpack://_N_E/./node_modules/.pnpm/@sentry+nextjs@7.12.1_next@12.2.5+react@18.2.0/node_modules/@sentry/nextjs/esm/utils/_error.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/global.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/env.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/node.js","webpack://_N_E/./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/time.js","webpack://_N_E/./node_modules/.pnpm/next@12.2.5_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/build/polyfills/process.js","webpack://_N_E/./node_modules/.pnpm/next@12.2.5_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/process/browser.js","webpack://_N_E/./node_modules/.pnpm/next@12.2.5_biqbaboplfbrettd7655fr4n2y/node_modules/next/error.js","webpack://_N_E/./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_async_to_generator.mjs","webpack://_N_E/<anon>"],"sourcesContent":["import { getGlobalObject } from './global.js';\nimport { addNonEnumerableProperty } from './object.js';\nimport { snipLine } from './string.js';\n\n/**\n * Extended Window interface that allows for Crypto API usage in IE browsers\n */\n\n/**\n * UUID4 generator\n *\n * @returns string Generated UUID4.\n */\nfunction uuid4() {\n  var global = getGlobalObject() ;\n  var crypto = (global.crypto || global.msCrypto) ;\n\n  if (crypto && crypto.randomUUID) {\n    return crypto.randomUUID().replace(/-/g, '');\n  }\n\n  var getRandomByte =\n    crypto && crypto.getRandomValues ? () => crypto.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n  // Concatenating the following numbers as strings results in '10000000100040008000100000000000'\n  return (([1e7] ) + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, c =>\n        ((c ) ^ ((getRandomByte() & 15) >> ((c ) / 4))).toString(16),\n  );\n}\n\nfunction getFirstException(event) {\n  return event.exception && event.exception.values ? event.exception.values[0] : undefined;\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nfunction getEventDescription(event) {\n  const { message, event_id: eventId } = event;\n  if (message) {\n    return message;\n  }\n\n  var firstException = getFirstException(event);\n  if (firstException) {\n    if (firstException.type && firstException.value) {\n      return `${firstException.type}: ${firstException.value}`;\n    }\n    return firstException.type || firstException.value || eventId || '<unknown>';\n  }\n  return eventId || '<unknown>';\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */\nfunction addExceptionTypeValue(event, value, type) {\n  var exception = (event.exception = event.exception || {});\n  var values = (exception.values = exception.values || []);\n  var firstException = (values[0] = values[0] || {});\n  if (!firstException.value) {\n    firstException.value = value || '';\n  }\n  if (!firstException.type) {\n    firstException.type = type || 'Error';\n  }\n}\n\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */\nfunction addExceptionMechanism(event, newMechanism) {\n  var firstException = getFirstException(event);\n  if (!firstException) {\n    return;\n  }\n\n  var defaultMechanism = { type: 'generic', handled: true };\n  var currentMechanism = firstException.mechanism;\n  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };\n\n  if (newMechanism && 'data' in newMechanism) {\n    var mergedData = { ...(currentMechanism && currentMechanism.data), ...newMechanism.data };\n    firstException.mechanism.data = mergedData;\n  }\n}\n\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nvar SEMVER_REGEXP =\n  /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n\n/**\n * Represents Semantic Versioning object\n */\n\n/**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */\nfunction parseSemver(input) {\n  var match = input.match(SEMVER_REGEXP) || [];\n  var major = parseInt(match[1], 10);\n  var minor = parseInt(match[2], 10);\n  var patch = parseInt(match[3], 10);\n  return {\n    buildmetadata: match[5],\n    major: isNaN(major) ? undefined : major,\n    minor: isNaN(minor) ? undefined : minor,\n    patch: isNaN(patch) ? undefined : patch,\n    prerelease: match[4],\n  };\n}\n\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */\nfunction addContextToFrame(lines, frame, linesOfContext = 5) {\n  var lineno = frame.lineno || 0;\n  var maxLines = lines.length;\n  var sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);\n\n  frame.pre_context = lines\n    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)\n    .map((line) => snipLine(line, 0));\n\n  frame.context_line = snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);\n\n  frame.post_context = lines\n    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)\n    .map((line) => snipLine(line, 0));\n}\n\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */\nfunction checkOrSetAlreadyCaught(exception) {\n    if (exception && (exception ).__sentry_captured__) {\n    return true;\n  }\n\n  try {\n    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n    // `ExtraErrorData` integration\n    addNonEnumerableProperty(exception , '__sentry_captured__', true);\n  } catch (err) {\n    // `exception` is a primitive, so we can't mark it seen\n  }\n\n  return false;\n}\n\n/**\n * Checks whether the given input is already an array, and if it isn't, wraps it in one.\n *\n * @param maybeArray Input to turn into an array, if necessary\n * @returns The input, if already an array, or an array with the input as the only element, if not\n */\nfunction arrayify(maybeArray) {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n}\n\nexport { addContextToFrame, addExceptionMechanism, addExceptionTypeValue, arrayify, checkOrSetAlreadyCaught, getEventDescription, parseSemver, uuid4 };\n//# sourceMappingURL=misc.js.map\n","import { getGlobalObject, getGlobalSingleton } from './global.js';\n\n// TODO: Implement different loggers for different environments\nvar global = getGlobalObject();\n\n/** Prefix for logging strings */\nvar PREFIX = 'Sentry Logger ';\n\nvar CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert', 'trace'] ;\n\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nfunction consoleSandbox(callback) {\n  var global = getGlobalObject();\n\n  if (!('console' in global)) {\n    return callback();\n  }\n\n  var originalConsole = global.console ;\n  var wrappedLevels = {};\n\n  // Restore all wrapped console methods\n  CONSOLE_LEVELS.forEach(level => {\n    // TODO(v7): Remove this check as it's only needed for Node 6\n    var originalWrappedFunc =\n      originalConsole[level] && (originalConsole[level] ).__sentry_original__;\n    if (level in global.console && originalWrappedFunc) {\n      wrappedLevels[level] = originalConsole[level] ;\n      originalConsole[level] = originalWrappedFunc ;\n    }\n  });\n\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    Object.keys(wrappedLevels).forEach(level => {\n      originalConsole[level] = wrappedLevels[level ];\n    });\n  }\n}\n\nfunction makeLogger() {\n  let enabled = false;\n  var logger = {\n    enable: () => {\n      enabled = true;\n    },\n    disable: () => {\n      enabled = false;\n    },\n  };\n\n  if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n    CONSOLE_LEVELS.forEach(name => {\n            logger[name] = (...args) => {\n        if (enabled) {\n          consoleSandbox(() => {\n            global.console[name](`${PREFIX}[${name}]:`, ...args);\n          });\n        }\n      };\n    });\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      logger[name] = () => undefined;\n    });\n  }\n\n  return logger ;\n}\n\n// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used\nlet logger;\nif ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n  logger = getGlobalSingleton('logger', makeLogger);\n} else {\n  logger = makeLogger();\n}\n\nexport { CONSOLE_LEVELS, consoleSandbox, logger };\n//# sourceMappingURL=logger.js.map\n","var objectToString = Object.prototype.toString;\n\n/**\n * Checks whether given value's type is one of a few Error or Error-like\n * {@link isError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isError(wat) {\n  switch (objectToString.call(wat)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n      return true;\n    default:\n      return isInstanceOf(wat, Error);\n  }\n}\n/**\n * Checks whether given value is an instance of the given built-in class.\n *\n * @param wat The value to be checked\n * @param className\n * @returns A boolean representing the result.\n */\nfunction isBuiltin(wat, className) {\n  return objectToString.call(wat) === `[object ${className}]`;\n}\n\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isErrorEvent(wat) {\n  return isBuiltin(wat, 'ErrorEvent');\n}\n\n/**\n * Checks whether given value's type is DOMError\n * {@link isDOMError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMError(wat) {\n  return isBuiltin(wat, 'DOMError');\n}\n\n/**\n * Checks whether given value's type is DOMException\n * {@link isDOMException}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMException(wat) {\n  return isBuiltin(wat, 'DOMException');\n}\n\n/**\n * Checks whether given value's type is a string\n * {@link isString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isString(wat) {\n  return isBuiltin(wat, 'String');\n}\n\n/**\n * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)\n * {@link isPrimitive}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPrimitive(wat) {\n  return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');\n}\n\n/**\n * Checks whether given value's type is an object literal\n * {@link isPlainObject}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPlainObject(wat) {\n  return isBuiltin(wat, 'Object');\n}\n\n/**\n * Checks whether given value's type is an Event instance\n * {@link isEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isEvent(wat) {\n  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\n}\n\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isElement(wat) {\n  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\n}\n\n/**\n * Checks whether given value's type is an regexp\n * {@link isRegExp}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isRegExp(wat) {\n  return isBuiltin(wat, 'RegExp');\n}\n\n/**\n * Checks whether given value has a then function.\n * @param wat A value to be checked.\n */\nfunction isThenable(wat) {\n    return Boolean(wat && wat.then && typeof wat.then === 'function');\n}\n\n/**\n * Checks whether given value's type is a SyntheticEvent\n * {@link isSyntheticEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isSyntheticEvent(wat) {\n  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;\n}\n\n/**\n * Checks whether given value is NaN\n * {@link isNaN}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isNaN(wat) {\n  return typeof wat === 'number' && wat !== wat;\n}\n\n/**\n * Checks whether given value's type is an instance of provided constructor.\n * {@link isInstanceOf}.\n *\n * @param wat A value to be checked.\n * @param base A constructor to be used in a check.\n * @returns A boolean representing the result.\n */\nfunction isInstanceOf(wat, base) {\n  try {\n    return wat instanceof base;\n  } catch (_e) {\n    return false;\n  }\n}\n\nexport { isDOMError, isDOMException, isElement, isError, isErrorEvent, isEvent, isInstanceOf, isNaN, isPlainObject, isPrimitive, isRegExp, isString, isSyntheticEvent, isThenable };\n//# sourceMappingURL=is.js.map\n","import { isThenable } from './is.js';\n\n/** SyncPromise internal states */\nvar States; (function (States) {\n  /** Pending */\n  var PENDING = 0; States[States[\"PENDING\"] = PENDING] = \"PENDING\";\n  /** Resolved / OK */\n  var RESOLVED = 1; States[States[\"RESOLVED\"] = RESOLVED] = \"RESOLVED\";\n  /** Rejected / Error */\n  var REJECTED = 2; States[States[\"REJECTED\"] = REJECTED] = \"REJECTED\";\n})(States || (States = {}));\n\n// Overloads so we can call resolvedSyncPromise without arguments and generic argument\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nfunction resolvedSyncPromise(value) {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nfunction rejectedSyncPromise(reason) {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nclass SyncPromise {\n   __init() {this._state = States.PENDING;}\n   __init2() {this._handlers = [];}\n  \n\n   constructor(\n    executor,\n  ) {;SyncPromise.prototype.__init.call(this);SyncPromise.prototype.__init2.call(this);SyncPromise.prototype.__init3.call(this);SyncPromise.prototype.__init4.call(this);SyncPromise.prototype.__init5.call(this);SyncPromise.prototype.__init6.call(this);\n    try {\n      executor(this._resolve, this._reject);\n    } catch (e) {\n      this._reject(e);\n    }\n  }\n\n  /** JSDoc */\n   then(\n    onfulfilled,\n    onrejected,\n  ) {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([\n        false,\n        result => {\n          if (!onfulfilled) {\n            // TODO: ¯\\_(ツ)_/¯\n            // TODO: FIXME\n            resolve(result );\n          } else {\n            try {\n              resolve(onfulfilled(result));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n        reason => {\n          if (!onrejected) {\n            reject(reason);\n          } else {\n            try {\n              resolve(onrejected(reason));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n      ]);\n      this._executeHandlers();\n    });\n  }\n\n  /** JSDoc */\n   catch(\n    onrejected,\n  ) {\n    return this.then(val => val, onrejected);\n  }\n\n  /** JSDoc */\n   finally(onfinally) {\n    return new SyncPromise((resolve, reject) => {\n      let val;\n      let isRejected;\n\n      return this.then(\n        value => {\n          isRejected = false;\n          val = value;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n        reason => {\n          isRejected = true;\n          val = reason;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n      ).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val );\n      });\n    });\n  }\n\n  /** JSDoc */\n    __init3() {this._resolve = (value) => {\n    this._setResult(States.RESOLVED, value);\n  };}\n\n  /** JSDoc */\n    __init4() {this._reject = (reason) => {\n    this._setResult(States.REJECTED, reason);\n  };}\n\n  /** JSDoc */\n    __init5() {this._setResult = (state, value) => {\n    if (this._state !== States.PENDING) {\n      return;\n    }\n\n    if (isThenable(value)) {\n      void (value ).then(this._resolve, this._reject);\n      return;\n    }\n\n    this._state = state;\n    this._value = value;\n\n    this._executeHandlers();\n  };}\n\n  /** JSDoc */\n    __init6() {this._executeHandlers = () => {\n    if (this._state === States.PENDING) {\n      return;\n    }\n\n    var cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n\n      if (this._state === States.RESOLVED) {\n                handler[1](this._value );\n      }\n\n      if (this._state === States.REJECTED) {\n        handler[2](this._value);\n      }\n\n      handler[0] = true;\n    });\n  };}\n}\n\nexport { SyncPromise, rejectedSyncPromise, resolvedSyncPromise };\n//# sourceMappingURL=syncpromise.js.map\n","import { getGlobalObject } from './global.js';\nimport { isString } from './is.js';\n\n/**\n * Given a child DOM element, returns a query-selector statement describing that\n * and its ancestors\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction htmlTreeAsString(elem, keyAttrs) {\n  \n\n  // try/catch both:\n  // - accessing event.target (see getsentry/raven-js#838, #768)\n  // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\n  // - can throw an exception in some circumstances.\n  try {\n    let currentElem = elem ;\n    var MAX_TRAVERSE_HEIGHT = 5;\n    var MAX_OUTPUT_LEN = 80;\n    var out = [];\n    let height = 0;\n    let len = 0;\n    var separator = ' > ';\n    var sepLength = separator.length;\n    let nextStr;\n\n        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {\n      nextStr = _htmlElementAsString(currentElem, keyAttrs);\n      // bail out if\n      // - nextStr is the 'html' element\n      // - the length of the string that would be created exceeds MAX_OUTPUT_LEN\n      //   (ignore this limit if we are on the first iteration)\n      if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {\n        break;\n      }\n\n      out.push(nextStr);\n\n      len += nextStr.length;\n      currentElem = currentElem.parentNode;\n    }\n\n    return out.reverse().join(separator);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/**\n * Returns a simple, query-selector representation of a DOM element\n * e.g. [HTMLElement] => input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction _htmlElementAsString(el, keyAttrs) {\n  var elem = el \n\n;\n\n  var out = [];\n  let className;\n  let classes;\n  let key;\n  let attr;\n  let i;\n\n  if (!elem || !elem.tagName) {\n    return '';\n  }\n\n  out.push(elem.tagName.toLowerCase());\n\n  // Pairs of attribute keys defined in `serializeAttribute` and their values on element.\n  var keyAttrPairs =\n    keyAttrs && keyAttrs.length\n      ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])\n      : null;\n\n  if (keyAttrPairs && keyAttrPairs.length) {\n    keyAttrPairs.forEach(keyAttrPair => {\n      out.push(`[${keyAttrPair[0]}=\"${keyAttrPair[1]}\"]`);\n    });\n  } else {\n    if (elem.id) {\n      out.push(`#${elem.id}`);\n    }\n\n        className = elem.className;\n    if (className && isString(className)) {\n      classes = className.split(/\\s+/);\n      for (i = 0; i < classes.length; i++) {\n        out.push(`.${classes[i]}`);\n      }\n    }\n  }\n  var allowedAttrs = ['type', 'name', 'title', 'alt'];\n  for (i = 0; i < allowedAttrs.length; i++) {\n    key = allowedAttrs[i];\n    attr = elem.getAttribute(key);\n    if (attr) {\n      out.push(`[${key}=\"${attr}\"]`);\n    }\n  }\n  return out.join('');\n}\n\n/**\n * A safe form of location.href\n */\nfunction getLocationHref() {\n  var global = getGlobalObject();\n  try {\n    return global.document.location.href;\n  } catch (oO) {\n    return '';\n  }\n}\n\n/**\n * Gets a DOM element by using document.querySelector.\n *\n * This wrapper will first check for the existance of the function before\n * actually calling it so that we don't have to take care of this check,\n * every time we want to access the DOM.\n *\n * Reason: DOM/querySelector is not available in all environments.\n *\n * We have to cast to any because utils can be consumed by a variety of environments,\n * and we don't want to break TS users. If you know what element will be selected by\n * `document.querySelector`, specify it as part of the generic call. For example,\n * `var element = getDomElement<Element>('selector');`\n *\n * @param selector the selector string passed on to document.querySelector\n */\nfunction getDomElement(selector) {\n  var global = getGlobalObject();\n  if (global.document && global.document.querySelector) {\n    return global.document.querySelector(selector) ;\n  }\n  return null;\n}\n\nexport { getDomElement, getLocationHref, htmlTreeAsString };\n//# sourceMappingURL=browser.js.map\n","import { htmlTreeAsString } from './browser.js';\nimport { isError, isEvent, isInstanceOf, isElement, isPlainObject, isPrimitive } from './is.js';\nimport { truncate } from './string.js';\n\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */\nfunction fill(source, name, replacementFactory) {\n  if (!(name in source)) {\n    return;\n  }\n\n  var original = source[name] ;\n  var wrapped = replacementFactory(original) ;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    try {\n      markFunctionWrapped(wrapped, original);\n    } catch (_Oo) {\n      // This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n\n  source[name] = wrapped;\n}\n\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */\nfunction addNonEnumerableProperty(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n    value: value,\n    writable: true,\n    configurable: true,\n  });\n}\n\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */\nfunction markFunctionWrapped(wrapped, original) {\n  var proto = original.prototype || {};\n  wrapped.prototype = original.prototype = proto;\n  addNonEnumerableProperty(wrapped, '__sentry_original__', original);\n}\n\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */\nfunction getOriginalFunction(func) {\n  return func.__sentry_original__;\n}\n\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\nfunction urlEncode(object) {\n  return Object.keys(object)\n    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)\n    .join('&');\n}\n\n/**\n * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their\n * non-enumerable properties attached.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n * @returns An Event or Error turned into an object - or the value argurment itself, when value is neither an Event nor\n *  an Error.\n */\nfunction convertToPlainObject(\n  value,\n)\n\n {\n  if (isError(value)) {\n    return {\n      message: value.message,\n      name: value.name,\n      stack: value.stack,\n      ...getOwnProperties(value),\n    };\n  } else if (isEvent(value)) {\n    var newObj\n\n = {\n      type: value.type,\n      target: serializeEventTarget(value.target),\n      currentTarget: serializeEventTarget(value.currentTarget),\n      ...getOwnProperties(value),\n    };\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      newObj.detail = value.detail;\n    }\n\n    return newObj;\n  } else {\n    return value;\n  }\n}\n\n/** Creates a string representation of the target of an `Event` object */\nfunction serializeEventTarget(target) {\n  try {\n    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/** Filters out all but an object's own properties */\nfunction getOwnProperties(obj) {\n  if (typeof obj === 'object' && obj !== null) {\n    var extractedProps = {};\n    for (var property in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, property)) {\n        extractedProps[property] = (obj )[property];\n      }\n    }\n    return extractedProps;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\nfunction extractExceptionKeysForMessage(exception, maxLength = 40) {\n  var keys = Object.keys(convertToPlainObject(exception));\n  keys.sort();\n\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n\n  if (keys[0].length >= maxLength) {\n    return truncate(keys[0], maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    var serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return a new object having removed all fields whose value was `undefined`.\n * Works recursively on objects and arrays.\n *\n * Attention: This function keeps circular references in the returned object.\n */\nfunction dropUndefinedKeys(inputValue) {\n  // This map keeps track of what already visited nodes map to.\n  // Our Set - based memoBuilder doesn't work here because we want to the output object to have the same circular\n  // references as the input object.\n  var memoizationMap = new Map();\n\n  // This function just proxies `_dropUndefinedKeys` to keep the `memoBuilder` out of this function's API\n  return _dropUndefinedKeys(inputValue, memoizationMap);\n}\n\nfunction _dropUndefinedKeys(inputValue, memoizationMap) {\n  if (isPlainObject(inputValue)) {\n    // If this node has already been visited due to a circular reference, return the object it was mapped to in the new object\n    var memoVal = memoizationMap.get(inputValue);\n    if (memoVal !== undefined) {\n      return memoVal ;\n    }\n\n    var returnValue = {};\n    // Store the mapping of this value in case we visit it again, in case of circular data\n    memoizationMap.set(inputValue, returnValue);\n\n    for (var key of Object.keys(inputValue)) {\n      if (typeof inputValue[key] !== 'undefined') {\n        returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);\n      }\n    }\n\n    return returnValue ;\n  }\n\n  if (Array.isArray(inputValue)) {\n    // If this node has already been visited due to a circular reference, return the array it was mapped to in the new object\n    var memoVal = memoizationMap.get(inputValue);\n    if (memoVal !== undefined) {\n      return memoVal ;\n    }\n\n    var returnValue = [];\n    // Store the mapping of this value in case we visit it again, in case of circular data\n    memoizationMap.set(inputValue, returnValue);\n\n    inputValue.forEach((item) => {\n      returnValue.push(_dropUndefinedKeys(item, memoizationMap));\n    });\n\n    return returnValue ;\n  }\n\n  return inputValue;\n}\n\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */\nfunction objectify(wat) {\n  let objectified;\n  switch (true) {\n    case wat === undefined || wat === null:\n      objectified = new String(wat);\n      break;\n\n    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n    // an object in order to wrap it.\n    case typeof wat === 'symbol' || typeof wat === 'bigint':\n      objectified = Object(wat);\n      break;\n\n    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n    case isPrimitive(wat):\n            objectified = new (wat ).constructor(wat);\n      break;\n\n    // by process of elimination, at this point we know that `wat` must already be an object\n    default:\n      objectified = wat;\n      break;\n  }\n  return objectified;\n}\n\nexport { addNonEnumerableProperty, convertToPlainObject, dropUndefinedKeys, extractExceptionKeysForMessage, fill, getOriginalFunction, markFunctionWrapped, objectify, urlEncode };\n//# sourceMappingURL=object.js.map\n","import { timestampInSeconds, uuid4, dropUndefinedKeys } from '@sentry/utils';\n\n/**\n * Creates a new `Session` object by setting certain default parameters. If optional @param context\n * is passed, the passed properties are applied to the session object.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns a new `Session` object\n */\nfunction makeSession(context) {\n  // Both timestamp and started are in seconds since the UNIX epoch.\n  var startingTime = timestampInSeconds();\n\n  var session = {\n    sid: uuid4(),\n    init: true,\n    timestamp: startingTime,\n    started: startingTime,\n    duration: 0,\n    status: 'ok',\n    errors: 0,\n    ignoreDuration: false,\n    toJSON: () => sessionToJSON(session),\n  };\n\n  if (context) {\n    updateSession(session, context);\n  }\n\n  return session;\n}\n\n/**\n * Updates a session object with the properties passed in the context.\n *\n * Note that this function mutates the passed object and returns void.\n * (Had to do this instead of returning a new and updated session because closing and sending a session\n * makes an update to the session after it was passed to the sending logic.\n * @see BaseClient.captureSession )\n *\n * @param session the `Session` to update\n * @param context the `SessionContext` holding the properties that should be updated in @param session\n */\nfunction updateSession(session, context = {}) {\n  if (context.user) {\n    if (!session.ipAddress && context.user.ip_address) {\n      session.ipAddress = context.user.ip_address;\n    }\n\n    if (!session.did && !context.did) {\n      session.did = context.user.id || context.user.email || context.user.username;\n    }\n  }\n\n  session.timestamp = context.timestamp || timestampInSeconds();\n\n  if (context.ignoreDuration) {\n    session.ignoreDuration = context.ignoreDuration;\n  }\n  if (context.sid) {\n    // Good enough uuid validation. — Kamil\n    session.sid = context.sid.length === 32 ? context.sid : uuid4();\n  }\n  if (context.init !== undefined) {\n    session.init = context.init;\n  }\n  if (!session.did && context.did) {\n    session.did = `${context.did}`;\n  }\n  if (typeof context.started === 'number') {\n    session.started = context.started;\n  }\n  if (session.ignoreDuration) {\n    session.duration = undefined;\n  } else if (typeof context.duration === 'number') {\n    session.duration = context.duration;\n  } else {\n    var duration = session.timestamp - session.started;\n    session.duration = duration >= 0 ? duration : 0;\n  }\n  if (context.release) {\n    session.release = context.release;\n  }\n  if (context.environment) {\n    session.environment = context.environment;\n  }\n  if (!session.ipAddress && context.ipAddress) {\n    session.ipAddress = context.ipAddress;\n  }\n  if (!session.userAgent && context.userAgent) {\n    session.userAgent = context.userAgent;\n  }\n  if (typeof context.errors === 'number') {\n    session.errors = context.errors;\n  }\n  if (context.status) {\n    session.status = context.status;\n  }\n}\n\n/**\n * Closes a session by setting its status and updating the session object with it.\n * Internally calls `updateSession` to update the passed session object.\n *\n * Note that this function mutates the passed session (@see updateSession for explanation).\n *\n * @param session the `Session` object to be closed\n * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,\n *               this function will keep the previously set status, unless it was `'ok'` in which case\n *               it is changed to `'exited'`.\n */\nfunction closeSession(session, status) {\n  let context = {};\n  if (status) {\n    context = { status };\n  } else if (session.status === 'ok') {\n    context = { status: 'exited' };\n  }\n\n  updateSession(session, context);\n}\n\n/**\n * Serializes a passed session object to a JSON object with a slightly different structure.\n * This is necessary because the Sentry backend requires a slightly different schema of a session\n * than the one the JS SDKs use internally.\n *\n * @param session the session to be converted\n *\n * @returns a JSON object of the passed session\n */\nfunction sessionToJSON(session) {\n  return dropUndefinedKeys({\n    sid: `${session.sid}`,\n    init: session.init,\n    // Make sure that sec is converted to ms for date constructor\n    started: new Date(session.started * 1000).toISOString(),\n    timestamp: new Date(session.timestamp * 1000).toISOString(),\n    status: session.status,\n    errors: session.errors,\n    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,\n    duration: session.duration,\n    attrs: {\n      release: session.release,\n      environment: session.environment,\n      ip_address: session.ipAddress,\n      user_agent: session.userAgent,\n    },\n  });\n}\n\nexport { closeSession, makeSession, updateSession };\n//# sourceMappingURL=session.js.map\n","import { isPlainObject, dateTimestampInSeconds, getGlobalSingleton, SyncPromise, logger, isThenable, arrayify } from '@sentry/utils';\nimport { updateSession } from './session.js';\n\n/**\n * Absolute maximum number of breadcrumbs added to an event.\n * The `maxBreadcrumbs` option cannot be higher than this value.\n */\nvar MAX_BREADCRUMBS = 100;\n\n/**\n * Holds additional event information. {@link Scope.applyToEvent} will be\n * called by the client before an event will be sent.\n */\nclass Scope  {\n  /** Flag if notifying is happening. */\n  \n\n  /** Callback for client to receive scope changes. */\n  \n\n  /** Callback list that will be called after {@link applyToEvent}. */\n  \n\n  /** Array of breadcrumbs. */\n  \n\n  /** User */\n  \n\n  /** Tags */\n  \n\n  /** Extra */\n  \n\n  /** Contexts */\n  \n\n  /** Attachments */\n  \n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n  \n\n  /** Fingerprint */\n  \n\n  /** Severity */\n    \n\n  /** Transaction Name */\n  \n\n  /** Span */\n  \n\n  /** Session */\n  \n\n  /** Request Mode Session Status */\n  \n\n   constructor() {\n    this._notifyingListeners = false;\n    this._scopeListeners = [];\n    this._eventProcessors = [];\n    this._breadcrumbs = [];\n    this._attachments = [];\n    this._user = {};\n    this._tags = {};\n    this._extra = {};\n    this._contexts = {};\n    this._sdkProcessingMetadata = {};\n  }\n\n  /**\n   * Inherit values from the parent scope.\n   * @param scope to clone.\n   */\n   static clone(scope) {\n    var newScope = new Scope();\n    if (scope) {\n      newScope._breadcrumbs = [...scope._breadcrumbs];\n      newScope._tags = { ...scope._tags };\n      newScope._extra = { ...scope._extra };\n      newScope._contexts = { ...scope._contexts };\n      newScope._user = scope._user;\n      newScope._level = scope._level;\n      newScope._span = scope._span;\n      newScope._session = scope._session;\n      newScope._transactionName = scope._transactionName;\n      newScope._fingerprint = scope._fingerprint;\n      newScope._eventProcessors = [...scope._eventProcessors];\n      newScope._requestSession = scope._requestSession;\n      newScope._attachments = [...scope._attachments];\n    }\n    return newScope;\n  }\n\n  /**\n   * Add internal on change listener. Used for sub SDKs that need to store the scope.\n   * @hidden\n   */\n   addScopeListener(callback) {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addEventProcessor(callback) {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setUser(user) {\n    this._user = user || {};\n    if (this._session) {\n      updateSession(this._session, { user });\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getUser() {\n    return this._user;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getRequestSession() {\n    return this._requestSession;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setRequestSession(requestSession) {\n    this._requestSession = requestSession;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTags(tags) {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTag(key, value) {\n    this._tags = { ...this._tags, [key]: value };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtras(extras) {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtra(key, extra) {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setFingerprint(fingerprint) {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setLevel(\n        level,\n  ) {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTransactionName(name) {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setContext(key, context) {\n    if (context === null) {\n            delete this._contexts[key];\n    } else {\n      this._contexts = { ...this._contexts, [key]: context };\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setSpan(span) {\n    this._span = span;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getSpan() {\n    return this._span;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getTransaction() {\n    // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will\n    // have a pointer to the currently-active transaction.\n    var span = this.getSpan();\n    return span && span.transaction;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setSession(session) {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getSession() {\n    return this._session;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   update(captureContext) {\n    if (!captureContext) {\n      return this;\n    }\n\n    if (typeof captureContext === 'function') {\n      var updatedScope = (captureContext )(this);\n      return updatedScope instanceof Scope ? updatedScope : this;\n    }\n\n    if (captureContext instanceof Scope) {\n      this._tags = { ...this._tags, ...captureContext._tags };\n      this._extra = { ...this._extra, ...captureContext._extra };\n      this._contexts = { ...this._contexts, ...captureContext._contexts };\n      if (captureContext._user && Object.keys(captureContext._user).length) {\n        this._user = captureContext._user;\n      }\n      if (captureContext._level) {\n        this._level = captureContext._level;\n      }\n      if (captureContext._fingerprint) {\n        this._fingerprint = captureContext._fingerprint;\n      }\n      if (captureContext._requestSession) {\n        this._requestSession = captureContext._requestSession;\n      }\n    } else if (isPlainObject(captureContext)) {\n            captureContext = captureContext ;\n      this._tags = { ...this._tags, ...captureContext.tags };\n      this._extra = { ...this._extra, ...captureContext.extra };\n      this._contexts = { ...this._contexts, ...captureContext.contexts };\n      if (captureContext.user) {\n        this._user = captureContext.user;\n      }\n      if (captureContext.level) {\n        this._level = captureContext.level;\n      }\n      if (captureContext.fingerprint) {\n        this._fingerprint = captureContext.fingerprint;\n      }\n      if (captureContext.requestSession) {\n        this._requestSession = captureContext.requestSession;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clear() {\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._requestSession = undefined;\n    this._span = undefined;\n    this._session = undefined;\n    this._notifyScopeListeners();\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addBreadcrumb(breadcrumb, maxBreadcrumbs) {\n    var maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    var mergedBreadcrumb = {\n      timestamp: dateTimestampInSeconds(),\n      ...breadcrumb,\n    };\n    this._breadcrumbs = [...this._breadcrumbs, mergedBreadcrumb].slice(-maxCrumbs);\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clearBreadcrumbs() {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addAttachment(attachment) {\n    this._attachments.push(attachment);\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getAttachments() {\n    return this._attachments;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clearAttachments() {\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * Applies data from the scope to the event and runs all event processors on it.\n   *\n   * @param event Event\n   * @param hint Object containing additional information about the original exception, for use by the event processors.\n   * @hidden\n   */\n   applyToEvent(event, hint = {}) {\n    if (this._extra && Object.keys(this._extra).length) {\n      event.extra = { ...this._extra, ...event.extra };\n    }\n    if (this._tags && Object.keys(this._tags).length) {\n      event.tags = { ...this._tags, ...event.tags };\n    }\n    if (this._user && Object.keys(this._user).length) {\n      event.user = { ...this._user, ...event.user };\n    }\n    if (this._contexts && Object.keys(this._contexts).length) {\n      event.contexts = { ...this._contexts, ...event.contexts };\n    }\n    if (this._level) {\n      event.level = this._level;\n    }\n    if (this._transactionName) {\n      event.transaction = this._transactionName;\n    }\n\n    // We want to set the trace context for normal events only if there isn't already\n    // a trace context on the event. There is a product feature in place where we link\n    // errors with transaction and it relies on that.\n    if (this._span) {\n      event.contexts = { trace: this._span.getTraceContext(), ...event.contexts };\n      var transactionName = this._span.transaction && this._span.transaction.name;\n      if (transactionName) {\n        event.tags = { transaction: transactionName, ...event.tags };\n      }\n    }\n\n    this._applyFingerprint(event);\n\n    event.breadcrumbs = [...(event.breadcrumbs || []), ...this._breadcrumbs];\n    event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;\n\n    event.sdkProcessingMetadata = { ...event.sdkProcessingMetadata, ...this._sdkProcessingMetadata };\n\n    return this._notifyEventProcessors([...getGlobalEventProcessors(), ...this._eventProcessors], event, hint);\n  }\n\n  /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry\n   */\n   setSDKProcessingMetadata(newData) {\n    this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };\n\n    return this;\n  }\n\n  /**\n   * This will be called after {@link applyToEvent} is finished.\n   */\n   _notifyEventProcessors(\n    processors,\n    event,\n    hint,\n    index = 0,\n  ) {\n    return new SyncPromise((resolve, reject) => {\n      var processor = processors[index];\n      if (event === null || typeof processor !== 'function') {\n        resolve(event);\n      } else {\n        var result = processor({ ...event }, hint) ;\n\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n          processor.id &&\n          result === null &&\n          logger.log(`Event processor \"${processor.id}\" dropped event`);\n\n        if (isThenable(result)) {\n          void result\n            .then(final => this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve))\n            .then(null, reject);\n        } else {\n          void this._notifyEventProcessors(processors, result, hint, index + 1)\n            .then(resolve)\n            .then(null, reject);\n        }\n      }\n    });\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n   _notifyScopeListeners() {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n\n  /**\n   * Applies fingerprint from the scope to the event if there's one,\n   * uses message if there's one instead or get rid of empty fingerprint\n   */\n   _applyFingerprint(event) {\n    // Make sure it's an array first and we actually have something in place\n    event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];\n\n    // If we have something on the scope, then merge it with event\n    if (this._fingerprint) {\n      event.fingerprint = event.fingerprint.concat(this._fingerprint);\n    }\n\n    // If we have no data at all, remove empty array default\n    if (event.fingerprint && !event.fingerprint.length) {\n      delete event.fingerprint;\n    }\n  }\n}\n\n/**\n * Returns the global event processors.\n */\nfunction getGlobalEventProcessors() {\n  return getGlobalSingleton('globalEventProcessors', () => []);\n}\n\n/**\n * Add a EventProcessor to be kept globally.\n * @param callback EventProcessor to add\n */\nfunction addGlobalEventProcessor(callback) {\n  getGlobalEventProcessors().push(callback);\n}\n\nexport { Scope, addGlobalEventProcessor };\n//# sourceMappingURL=scope.js.map\n","import { uuid4, dateTimestampInSeconds, consoleSandbox, logger, getGlobalObject, getGlobalSingleton, isNodeEnv } from '@sentry/utils';\nimport { Scope } from './scope.js';\nimport { closeSession, makeSession, updateSession } from './session.js';\n\n/**\n * API compatibility version of this hub.\n *\n * WARNING: This number should only be increased when the global interface\n * changes and new methods are introduced.\n *\n * @hidden\n */\nvar API_VERSION = 4;\n\n/**\n * Default maximum number of breadcrumbs added to an event. Can be overwritten\n * with {@link Options.maxBreadcrumbs}.\n */\nvar DEFAULT_BREADCRUMBS = 100;\n\n/**\n * A layer in the process stack.\n * @hidden\n */\n\n/**\n * @inheritDoc\n */\nclass Hub  {\n  /** Is a {@link Layer}[] containing the client and scope */\n    __init() {this._stack = [{}];}\n\n  /** Contains the last event id of a captured event.  */\n  \n\n  /**\n   * Creates a new instance of the hub, will push one {@link Layer} into the\n   * internal stack on creation.\n   *\n   * @param client bound to the hub.\n   * @param scope bound to the hub.\n   * @param version number, higher number means higher priority.\n   */\n   constructor(client, scope = new Scope(),   _version = API_VERSION) {;this._version = _version;Hub.prototype.__init.call(this);\n    this.getStackTop().scope = scope;\n    if (client) {\n      this.bindClient(client);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   isOlderThan(version) {\n    return this._version < version;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   bindClient(client) {\n    var top = this.getStackTop();\n    top.client = client;\n    if (client && client.setupIntegrations) {\n      client.setupIntegrations();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   pushScope() {\n    // We want to clone the content of prev scope\n    var scope = Scope.clone(this.getScope());\n    this.getStack().push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   popScope() {\n    if (this.getStack().length <= 1) return false;\n    return !!this.getStack().pop();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   withScope(callback) {\n    var scope = this.pushScope();\n    try {\n      callback(scope);\n    } finally {\n      this.popScope();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getClient() {\n    return this.getStackTop().client ;\n  }\n\n  /** Returns the scope of the top stack. */\n   getScope() {\n    return this.getStackTop().scope;\n  }\n\n  /** Returns the scope stack for domains or the process. */\n   getStack() {\n    return this._stack;\n  }\n\n  /** Returns the topmost scope layer in the order domain > local > process. */\n   getStackTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  /**\n   * @inheritDoc\n   */\n     captureException(exception, hint) {\n    var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());\n    var syntheticException = new Error('Sentry syntheticException');\n    this._withClient((client, scope) => {\n      client.captureException(\n        exception,\n        {\n          originalException: exception,\n          syntheticException,\n          ...hint,\n          event_id: eventId,\n        },\n        scope,\n      );\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureMessage(\n    message,\n        level,\n    hint,\n  ) {\n    var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());\n    var syntheticException = new Error(message);\n    this._withClient((client, scope) => {\n      client.captureMessage(\n        message,\n        level,\n        {\n          originalException: message,\n          syntheticException,\n          ...hint,\n          event_id: eventId,\n        },\n        scope,\n      );\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint) {\n    var eventId = hint && hint.event_id ? hint.event_id : uuid4();\n    if (event.type !== 'transaction') {\n      this._lastEventId = eventId;\n    }\n\n    this._withClient((client, scope) => {\n      client.captureEvent(event, { ...hint, event_id: eventId }, scope);\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   lastEventId() {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addBreadcrumb(breadcrumb, hint) {\n    const { scope, client } = this.getStackTop();\n\n    if (!scope || !client) return;\n\n        const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } =\n      (client.getOptions && client.getOptions()) || {};\n\n    if (maxBreadcrumbs <= 0) return;\n\n    var timestamp = dateTimestampInSeconds();\n    var mergedBreadcrumb = { timestamp, ...breadcrumb };\n    var finalBreadcrumb = beforeBreadcrumb\n      ? (consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) )\n      : mergedBreadcrumb;\n\n    if (finalBreadcrumb === null) return;\n\n    scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setUser(user) {\n    var scope = this.getScope();\n    if (scope) scope.setUser(user);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTags(tags) {\n    var scope = this.getScope();\n    if (scope) scope.setTags(tags);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtras(extras) {\n    var scope = this.getScope();\n    if (scope) scope.setExtras(extras);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTag(key, value) {\n    var scope = this.getScope();\n    if (scope) scope.setTag(key, value);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtra(key, extra) {\n    var scope = this.getScope();\n    if (scope) scope.setExtra(key, extra);\n  }\n\n  /**\n   * @inheritDoc\n   */\n     setContext(name, context) {\n    var scope = this.getScope();\n    if (scope) scope.setContext(name, context);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   configureScope(callback) {\n    const { scope, client } = this.getStackTop();\n    if (scope && client) {\n      callback(scope);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   run(callback) {\n    var oldHub = makeMain(this);\n    try {\n      callback(this);\n    } finally {\n      makeMain(oldHub);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getIntegration(integration) {\n    var client = this.getClient();\n    if (!client) return null;\n    try {\n      return client.getIntegration(integration);\n    } catch (_oO) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   startTransaction(context, customSamplingContext) {\n    return this._callExtensionMethod('startTransaction', context, customSamplingContext);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   traceHeaders() {\n    return this._callExtensionMethod('traceHeaders');\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureSession(endSession = false) {\n    // both send the update and pull the session from the scope\n    if (endSession) {\n      return this.endSession();\n    }\n\n    // only send the update\n    this._sendSessionUpdate();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   endSession() {\n    var layer = this.getStackTop();\n    var scope = layer && layer.scope;\n    var session = scope && scope.getSession();\n    if (session) {\n      closeSession(session);\n    }\n    this._sendSessionUpdate();\n\n    // the session is over; take it off of the scope\n    if (scope) {\n      scope.setSession();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   startSession(context) {\n    const { scope, client } = this.getStackTop();\n    const { release, environment } = (client && client.getOptions()) || {};\n\n    // Will fetch userAgent if called from browser sdk\n    var global = getGlobalObject();\n    const { userAgent } = global.navigator || {};\n\n    var session = makeSession({\n      release,\n      environment,\n      ...(scope && { user: scope.getUser() }),\n      ...(userAgent && { userAgent }),\n      ...context,\n    });\n\n    if (scope) {\n      // End existing session if there's one\n      var currentSession = scope.getSession && scope.getSession();\n      if (currentSession && currentSession.status === 'ok') {\n        updateSession(currentSession, { status: 'exited' });\n      }\n      this.endSession();\n\n      // Afterwards we set the new session on the scope\n      scope.setSession(session);\n    }\n\n    return session;\n  }\n\n  /**\n   * Returns if default PII should be sent to Sentry and propagated in ourgoing requests\n   * when Tracing is used.\n   */\n   shouldSendDefaultPii() {\n    var client = this.getClient();\n    var options = client && client.getOptions();\n    return Boolean(options && options.sendDefaultPii);\n  }\n\n  /**\n   * Sends the current Session on the scope\n   */\n   _sendSessionUpdate() {\n    const { scope, client } = this.getStackTop();\n    if (!scope) return;\n\n    var session = scope.getSession();\n    if (session) {\n      if (client && client.captureSession) {\n        client.captureSession(session);\n      }\n    }\n  }\n\n  /**\n   * Internal helper function to call a method on the top client if it exists.\n   *\n   * @param method The method to call on the client.\n   * @param args Arguments to pass to the client function.\n   */\n   _withClient(callback) {\n    const { scope, client } = this.getStackTop();\n    if (client) {\n      callback(client, scope);\n    }\n  }\n\n  /**\n   * Calls global extension method and binding current instance to the function call\n   */\n  // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)\n     _callExtensionMethod(method, ...args) {\n    var carrier = getMainCarrier();\n    var sentry = carrier.__SENTRY__;\n    if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {\n      return sentry.extensions[method].apply(this, args);\n    }\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);\n  }\n}\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nfunction getMainCarrier() {\n  var carrier = getGlobalObject();\n  carrier.__SENTRY__ = carrier.__SENTRY__ || {\n    extensions: {},\n    hub: undefined,\n  };\n  return carrier;\n}\n\n/**\n * Replaces the current main hub with the passed one on the global object\n *\n * @returns The old replaced hub\n */\nfunction makeMain(hub) {\n  var registry = getMainCarrier();\n  var oldHub = getHubFromCarrier(registry);\n  setHubOnCarrier(registry, hub);\n  return oldHub;\n}\n\n/**\n * Returns the default hub instance.\n *\n * If a hub is already registered in the global carrier but this module\n * contains a more recent version, it replaces the registered version.\n * Otherwise, the currently registered hub will be returned.\n */\nfunction getCurrentHub() {\n  // Get main carrier (global for every environment)\n  var registry = getMainCarrier();\n\n  // If there's no hub, or its an old API, assign a new one\n  if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {\n    setHubOnCarrier(registry, new Hub());\n  }\n\n  // Prefer domains over global if they are there (applicable only to Node environment)\n  if (isNodeEnv()) {\n    return getHubFromActiveDomain(registry);\n  }\n  // Return hub that lives on a global object\n  return getHubFromCarrier(registry);\n}\n\n/**\n * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist\n * @returns discovered hub\n */\nfunction getHubFromActiveDomain(registry) {\n  try {\n    var sentry = getMainCarrier().__SENTRY__;\n    var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;\n\n    // If there's no active domain, just return global hub\n    if (!activeDomain) {\n      return getHubFromCarrier(registry);\n    }\n\n    // If there's no hub on current domain, or it's an old API, assign a new one\n    if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {\n      var registryHubTopStack = getHubFromCarrier(registry).getStackTop();\n      setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));\n    }\n\n    // Return hub that lives on a domain\n    return getHubFromCarrier(activeDomain);\n  } catch (_Oo) {\n    // Return hub that lives on a global object\n    return getHubFromCarrier(registry);\n  }\n}\n\n/**\n * This will tell whether a carrier has a hub on it or not\n * @param carrier object\n */\nfunction hasHubOnCarrier(carrier) {\n  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);\n}\n\n/**\n * This will create a new {@link Hub} and add to the passed object on\n * __SENTRY__.hub.\n * @param carrier object\n * @hidden\n */\nfunction getHubFromCarrier(carrier) {\n  return getGlobalSingleton('hub', () => new Hub(), carrier);\n}\n\n/**\n * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute\n * @param carrier object\n * @param hub Hub\n * @returns A boolean indicating success or failure\n */\nfunction setHubOnCarrier(carrier, hub) {\n  if (!carrier) return false;\n  var __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n  __SENTRY__.hub = hub;\n  return true;\n}\n\nexport { API_VERSION, Hub, getCurrentHub, getHubFromCarrier, getMainCarrier, makeMain, setHubOnCarrier };\n//# sourceMappingURL=hub.js.map\n","import { getCurrentHub } from './hub.js';\n\n// Note: All functions in this file are typed with a return value of `ReturnType<Hub[HUB_FUNCTION]>`,\n// where HUB_FUNCTION is some method on the Hub class.\n//\n// This is done to make sure the top level SDK methods stay in sync with the hub methods.\n// Although every method here has an explicit return type, some of them (that map to void returns) do not\n// contain `return` keywords. This is done to save on bundle size, as `return` is not minifiable.\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception An exception-like object.\n * @param captureContext Additional scope data to apply to exception event.\n * @returns The generated eventId.\n */\nfunction captureException(exception, captureContext) {\n  return getCurrentHub().captureException(exception, { captureContext });\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param Severity Define the level of the message.\n * @returns The generated eventId.\n */\nfunction captureMessage(\n  message,\n    captureContext,\n) {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  var level = typeof captureContext === 'string' ? captureContext : undefined;\n  var context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return getCurrentHub().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @returns The generated eventId.\n */\nfunction captureEvent(event, hint) {\n  return getCurrentHub().captureEvent(event, hint);\n}\n\n/**\n * Callback to set context information onto the scope.\n * @param callback Callback function that receives Scope.\n */\nfunction configureScope(callback) {\n  getCurrentHub().configureScope(callback);\n}\n\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user's actions prior to an error or crash.\n *\n * @param breadcrumb The breadcrumb to record.\n */\nfunction addBreadcrumb(breadcrumb) {\n  getCurrentHub().addBreadcrumb(breadcrumb);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nfunction setContext(name, context) {\n  getCurrentHub().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n  getCurrentHub().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n  getCurrentHub().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n  getCurrentHub().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n  getCurrentHub().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n  getCurrentHub().setUser(user);\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n *\n * This is essentially a convenience function for:\n *\n *     pushScope();\n *     callback();\n *     popScope();\n *\n * @param callback that will be enclosed into push/popScope.\n */\nfunction withScope(callback) {\n  getCurrentHub().withScope(callback);\n}\n\n/**\n * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n *\n * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n * new child span within the transaction or any span, call the respective `.startChild()` method.\n *\n * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n *\n * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its\n * finished child spans will be sent to Sentry.\n *\n * NOTE: This function should only be used for *manual* instrumentation. Auto-instrumentation should call\n * `startTransaction` directly on the hub.\n *\n * @param context Properties of the new `Transaction`.\n * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n * default values). See {@link Options.tracesSampler}.\n *\n * @returns The transaction which was just started\n */\nfunction startTransaction(\n  context,\n  customSamplingContext,\n) {\n  return getCurrentHub().startTransaction(\n    {\n      metadata: { source: 'custom' },\n      ...context,\n    },\n    customSamplingContext,\n  );\n}\n\nexport { addBreadcrumb, captureEvent, captureException, captureMessage, configureScope, setContext, setExtra, setExtras, setTag, setTags, setUser, startTransaction, withScope };\n//# sourceMappingURL=exports.js.map\n","/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase)\n * See https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\nfunction _optionalChain(ops) {\n  let lastAccessLHS = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    var op = ops[i] ;\n    var fn = ops[i + 1] ;\n    i += 2;\n    // by checking for loose equality to `null`, we catch both `null` and `undefined`\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      // really we're meaning to return `undefined` as an actual value here, but it saves bytes not to write it\n      return;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args) => (value ).call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\n\n// Sucrase version\n// function _optionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     var op = ops[i];\n//     var fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\n\nexport { _optionalChain };\n//# sourceMappingURL=_optionalChain.js.map\n","/**\n * Helper to decycle json objects\n */\nfunction memoBuilder() {\n  var hasWeakSet = typeof WeakSet === 'function';\n  var inner = hasWeakSet ? new WeakSet() : [];\n  function memoize(obj) {\n    if (hasWeakSet) {\n      if (inner.has(obj)) {\n        return true;\n      }\n      inner.add(obj);\n      return false;\n    }\n        for (let i = 0; i < inner.length; i++) {\n      var value = inner[i];\n      if (value === obj) {\n        return true;\n      }\n    }\n    inner.push(obj);\n    return false;\n  }\n\n  function unmemoize(obj) {\n    if (hasWeakSet) {\n      inner.delete(obj);\n    } else {\n      for (let i = 0; i < inner.length; i++) {\n        if (inner[i] === obj) {\n          inner.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n  return [memoize, unmemoize];\n}\n\nexport { memoBuilder };\n//# sourceMappingURL=memo.js.map\n","import { _optionalChain } from './buildPolyfills';\n\nvar STACKTRACE_LIMIT = 50;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nfunction createStackParser(...parsers) {\n  var sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack, skipFirst = 0) => {\n    var frames = [];\n\n    for (var line of stack.split('\\n').slice(skipFirst)) {\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      var cleanedLine = line.replace(/\\(error: (.*)\\)/, '$1');\n\n      for (var parser of sortedParsers) {\n        var frame = parser(cleanedLine);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nfunction stackParserFromStackParserOptions(stackParser) {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * @hidden\n */\nfunction stripSentryFramesAndReverse(stack) {\n  if (!stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n\n  var firstFrameFunction = localStack[0].function || '';\n  var lastFrameFunction = localStack[localStack.length - 1].function || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack\n    .slice(0, STACKTRACE_LIMIT)\n    .map(frame => ({\n      ...frame,\n      filename: frame.filename || localStack[0].filename,\n      function: frame.function || '?',\n    }))\n    .reverse();\n}\n\nvar defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nfunction getFunctionName(fn) {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\nfunction node(getModule) {\n  var FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  var FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n    return (line) => {\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line,\n      };\n    }\n\n    var lineMatch = line.match(FULL_MATCH);\n    if (!lineMatch) {\n      return undefined;\n    }\n\n    let object;\n    let method;\n    let functionName;\n    let typeName;\n    let methodName;\n\n    if (lineMatch[1]) {\n      functionName = lineMatch[1];\n\n      let methodStart = functionName.lastIndexOf('.');\n      if (functionName[methodStart - 1] === '.') {\n                methodStart--;\n      }\n\n      if (methodStart > 0) {\n        object = functionName.substr(0, methodStart);\n        method = functionName.substr(methodStart + 1);\n        var objectEnd = object.indexOf('.Module');\n        if (objectEnd > 0) {\n          functionName = functionName.substr(objectEnd + 1);\n          object = object.substr(0, objectEnd);\n        }\n      }\n      typeName = undefined;\n    }\n\n    if (method) {\n      typeName = object;\n      methodName = method;\n    }\n\n    if (method === '<anonymous>') {\n      methodName = undefined;\n      functionName = undefined;\n    }\n\n    if (functionName === undefined) {\n      methodName = methodName || '<anonymous>';\n      functionName = typeName ? `${typeName}.${methodName}` : methodName;\n    }\n\n    var filename = _optionalChain([lineMatch, 'access', _ => _[2], 'optionalAccess', _2 => _2.startsWith, 'call', _3 => _3('file://')]) ? lineMatch[2].substr(7) : lineMatch[2];\n    var isNative = lineMatch[5] === 'native';\n    var isInternal =\n      isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\\\') !== 1);\n\n    // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n    var in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n\n    return {\n      filename,\n      module: _optionalChain([getModule, 'optionalCall', _4 => _4(filename)]),\n      function: functionName,\n      lineno: parseInt(lineMatch[3], 10) || undefined,\n      colno: parseInt(lineMatch[4], 10) || undefined,\n      in_app,\n    };\n  };\n}\n\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */\nfunction nodeStackLineParser(getModule) {\n  return [90, node(getModule)];\n}\n\nexport { createStackParser, getFunctionName, nodeStackLineParser, stackParserFromStackParserOptions, stripSentryFramesAndReverse };\n//# sourceMappingURL=stacktrace.js.map\n","import { isNaN, isSyntheticEvent } from './is.js';\nimport { memoBuilder } from './memo.js';\nimport { convertToPlainObject } from './object.js';\nimport { getFunctionName } from './stacktrace.js';\n\n/**\n * Recursively normalizes the given object.\n *\n * - Creates a copy to prevent original input mutation\n * - Skips non-enumerable properties\n * - When stringifying, calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format\n * - Translates known global objects/classes to a string representations\n * - Takes care of `Error` object serialization\n * - Optionally limits depth of final output\n * - Optionally limits number of properties/elements included in any single object/array\n *\n * @param input The object to be normalized.\n * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)\n * @param maxProperties The max number of elements or properties to be included in any single array or\n * object in the normallized output.\n * @returns A normalized version of the object, or `\"**non-serializable**\"` if any errors are thrown during normalization.\n */\nfunction normalize(input, depth = +Infinity, maxProperties = +Infinity) {\n  try {\n    // since we're at the outermost level, we don't provide a key\n    return visit('', input, depth, maxProperties);\n  } catch (err) {\n    return { ERROR: `**non-serializable** (${err})` };\n  }\n}\n\n/** JSDoc */\nfunction normalizeToSize(\n    object,\n  // Default Node.js REPL depth\n  depth = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize = 100 * 1024,\n) {\n  var normalized = normalize(object, depth);\n\n  if (jsonSize(normalized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return normalized ;\n}\n\n/**\n * Visits a node to perform normalization on it\n *\n * @param key The key corresponding to the given node\n * @param value The node to be visited\n * @param depth Optional number indicating the maximum recursion depth\n * @param maxProperties Optional maximum number of properties/elements included in any single object/array\n * @param memo Optional Memo class handling decycling\n */\nfunction visit(\n  key,\n  value,\n  depth = +Infinity,\n  maxProperties = +Infinity,\n  memo = memoBuilder(),\n) {\n  const [memoize, unmemoize] = memo;\n\n  // Get the simple cases out of the way first\n  if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !isNaN(value))) {\n    return value ;\n  }\n\n  var stringified = stringifyValue(key, value);\n\n  // Anything we could potentially dig into more (objects or arrays) will have come back as `\"[object XXXX]\"`.\n  // Everything else will have already been serialized, so if we don't see that pattern, we're done.\n  if (!stringified.startsWith('[object ')) {\n    return stringified;\n  }\n\n  // From here on, we can assert that `value` is either an object or an array.\n\n  // Do not normalize objects that we know have already been normalized. As a general rule, the\n  // \"__sentry_skip_normalization__\" property should only be used sparingly and only should only be set on objects that\n  // have already been normalized.\n  if ((value )['__sentry_skip_normalization__']) {\n    return value ;\n  }\n\n  // We're also done if we've reached the max depth\n  if (depth === 0) {\n    // At this point we know `serialized` is a string of the form `\"[object XXXX]\"`. Clean it up so it's just `\"[XXXX]\"`.\n    return stringified.replace('object ', '');\n  }\n\n  // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.\n  if (memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // If the value has a `toJSON` method, we call it to extract more information\n  var valueWithToJSON = value ;\n  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {\n    try {\n      var jsonValue = valueWithToJSON.toJSON();\n      // We need to normalize the return value of `.toJSON()` in case it has circular references\n      return visit('', jsonValue, depth - 1, maxProperties, memo);\n    } catch (err) {\n      // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)\n    }\n  }\n\n  // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse\n  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each\n  // property/entry, and keep track of the number of items we add to it.\n  var normalized = (Array.isArray(value) ? [] : {}) ;\n  let numAdded = 0;\n\n  // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant\n  // properties are non-enumerable and otherwise would get missed.\n  var visitable = convertToPlainObject(value );\n\n  for (var visitKey in visitable) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n      continue;\n    }\n\n    if (numAdded >= maxProperties) {\n      normalized[visitKey] = '[MaxProperties ~]';\n      break;\n    }\n\n    // Recursively visit all the child nodes\n    var visitValue = visitable[visitKey];\n    normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);\n\n    numAdded += 1;\n  }\n\n  // Once we've visited all the branches, remove the parent from memo storage\n  unmemoize(value);\n\n  // Return accumulated values\n  return normalized;\n}\n\n/**\n * Stringify the given value. Handles various known special values and types.\n *\n * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn\n * the number 1231 into \"[Object Number]\", nor on `null`, as it will throw.\n *\n * @param value The value to stringify\n * @returns A stringified representation of the given value\n */\nfunction stringifyValue(\n  key,\n  // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for\n  // our internal use, it'll do\n  value,\n) {\n  try {\n    if (key === 'domain' && value && typeof value === 'object' && (value )._events) {\n      return '[Domain]';\n    }\n\n    if (key === 'domainEmitter') {\n      return '[DomainEmitter]';\n    }\n\n    // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first\n    // which won't throw if they are not present.\n\n    if (typeof global !== 'undefined' && value === global) {\n      return '[Global]';\n    }\n\n        if (typeof window !== 'undefined' && value === window) {\n      return '[Window]';\n    }\n\n        if (typeof document !== 'undefined' && value === document) {\n      return '[Document]';\n    }\n\n    // React's SyntheticEvent thingy\n    if (isSyntheticEvent(value)) {\n      return '[SyntheticEvent]';\n    }\n\n    if (typeof value === 'number' && value !== value) {\n      return '[NaN]';\n    }\n\n    // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)\n    if (value === void 0) {\n      return '[undefined]';\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${getFunctionName(value)}]`;\n    }\n\n    if (typeof value === 'symbol') {\n      return `[${String(value)}]`;\n    }\n\n    // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion\n    if (typeof value === 'bigint') {\n      return `[BigInt: ${String(value)}]`;\n    }\n\n    // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting\n    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as\n    // `\"[object Object]\"`. If we instead look at the constructor's name (which is the same as the name of the class),\n    // we can make sure that only plain objects come out that way.\n    return `[object ${(Object.getPrototypeOf(value) ).constructor.name}]`;\n  } catch (err) {\n    return `**non-serializable** (${err})`;\n  }\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value) {\n    return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\nfunction jsonSize(value) {\n  return utf8Length(JSON.stringify(value));\n}\n\nexport { normalize, normalizeToSize, visit as walk };\n//# sourceMappingURL=normalize.js.map\n","/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nfunction parseUrl(url)\n\n {\n  if (!url) {\n    return {};\n  }\n\n  var match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  var query = match[6] || '';\n  var fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nfunction stripUrlQueryAndFragment(urlPath) {\n    return urlPath.split(/[\\?#]/, 1)[0];\n}\n\n/**\n * Returns number of URL segments of a passed string URL.\n */\nfunction getNumberOfUrlSegments(url) {\n  // split at '/' or at '\\/' to split regex urls correctly\n  return url.split(/\\\\?\\//).filter(s => s.length > 0 && s !== ',').length;\n}\n\nexport { getNumberOfUrlSegments, parseUrl, stripUrlQueryAndFragment };\n//# sourceMappingURL=url.js.map\n","import { _optionalChain } from './buildPolyfills';\nimport { isString, isPlainObject } from './is.js';\nimport { normalize } from './normalize.js';\nimport { stripUrlQueryAndFragment } from './url.js';\n\nvar DEFAULT_INCLUDES = {\n  ip: false,\n  request: true,\n  transaction: true,\n  user: true,\n};\nvar DEFAULT_REQUEST_INCLUDES = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];\nvar DEFAULT_USER_INCLUDES = ['id', 'username', 'email'];\n\n/**\n * Sets parameterized route as transaction name e.g.: `GET /users/:id`\n * Also adds more context data on the transaction from the request\n */\nfunction addRequestDataToTransaction(\n  transaction,\n  req,\n  deps,\n) {\n  if (!transaction) return;\n  if (!transaction.metadata.source || transaction.metadata.source === 'url') {\n    // Attempt to grab a parameterized route off of the request\n    transaction.setName(...extractPathForTransaction(req, { path: true, method: true }));\n  }\n  transaction.setData('url', req.originalUrl || req.url);\n  if (req.baseUrl) {\n    transaction.setData('baseUrl', req.baseUrl);\n  }\n  transaction.setData('query', extractQueryParams(req, deps));\n}\n\n/**\n * Extracts a complete and parameterized path from the request object and uses it to construct transaction name.\n * If the parameterized transaction name cannot be extracted, we fall back to the raw URL.\n *\n * Additionally, this function determines and returns the transaction name source\n *\n * eg. GET /mountpoint/user/:id\n *\n * @param req A request object\n * @param options What to include in the transaction name (method, path, or a custom route name to be\n *                used instead of the request's route)\n *\n * @returns A tuple of the fully constructed transaction name [0] and its source [1] (can be either 'route' or 'url')\n */\nfunction extractPathForTransaction(\n  req,\n  options = {},\n) {\n  var method = req.method && req.method.toUpperCase();\n\n  let path = '';\n  let source = 'url';\n\n  // Check to see if there's a parameterized route we can use (as there is in Express)\n  if (options.customRoute || req.route) {\n    path = options.customRoute || `${req.baseUrl || ''}${req.route && req.route.path}`;\n    source = 'route';\n  }\n\n  // Otherwise, just take the original URL\n  else if (req.originalUrl || req.url) {\n    path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');\n  }\n\n  let name = '';\n  if (options.method && method) {\n    name += method;\n  }\n  if (options.method && options.path) {\n    name += ' ';\n  }\n  if (options.path && path) {\n    name += path;\n  }\n\n  return [name, source];\n}\n\n/** JSDoc */\nfunction extractTransaction(req, type) {\n  switch (type) {\n    case 'path': {\n      return extractPathForTransaction(req, { path: true })[0];\n    }\n    case 'handler': {\n      return (req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name) || '<anonymous>';\n    }\n    case 'methodPath':\n    default: {\n      return extractPathForTransaction(req, { path: true, method: true })[0];\n    }\n  }\n}\n\n/** JSDoc */\nfunction extractUserData(\n  user\n\n,\n  keys,\n) {\n  var extractedUser = {};\n  var attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;\n\n  attributes.forEach(key => {\n    if (user && key in user) {\n      extractedUser[key] = user[key];\n    }\n  });\n\n  return extractedUser;\n}\n\n/**\n * Normalize data from the request object, accounting for framework differences.\n *\n * @param req The request object from which to extract data\n * @param options.include An optional array of keys to include in the normalized data. Defaults to\n * DEFAULT_REQUEST_INCLUDES if not provided.\n * @param options.deps Injected, platform-specific dependencies\n * @returns An object containing normalized request data\n */\nfunction extractRequestData(\n  req,\n  options\n\n,\n) {\n  const { include = DEFAULT_REQUEST_INCLUDES, deps } = options || {};\n  var requestData = {};\n\n  // headers:\n  //   node, express, koa, nextjs: req.headers\n  var headers = (req.headers || {}) \n\n;\n  // method:\n  //   node, express, koa, nextjs: req.method\n  var method = req.method;\n  // host:\n  //   express: req.hostname in > 4 and req.host in < 4\n  //   koa: req.host\n  //   node, nextjs: req.headers.host\n  var host = req.hostname || req.host || headers.host || '<no host>';\n  // protocol:\n  //   node, nextjs: <n/a>\n  //   express, koa: req.protocol\n  var protocol = req.protocol === 'https' || (req.socket && req.socket.encrypted) ? 'https' : 'http';\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  var originalUrl = req.originalUrl || req.url || '';\n  // absolute url\n  var absoluteUrl = `${protocol}://${host}${originalUrl}`;\n  include.forEach(key => {\n    switch (key) {\n      case 'headers': {\n        requestData.headers = headers;\n        break;\n      }\n      case 'method': {\n        requestData.method = method;\n        break;\n      }\n      case 'url': {\n        requestData.url = absoluteUrl;\n        break;\n      }\n      case 'cookies': {\n        // cookies:\n        //   node, express, koa: req.headers.cookie\n        //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies\n                requestData.cookies =\n          // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can\n          // come off in v8\n          req.cookies || (headers.cookie && deps && deps.cookie && deps.cookie.parse(headers.cookie)) || {};\n        break;\n      }\n      case 'query_string': {\n        // query string:\n        //   node: req.url (raw)\n        //   express, koa, nextjs: req.query\n                requestData.query_string = extractQueryParams(req, deps);\n        break;\n      }\n      case 'data': {\n        if (method === 'GET' || method === 'HEAD') {\n          break;\n        }\n        // body data:\n        //   express, koa, nextjs: req.body\n        //\n        //   when using node by itself, you have to read the incoming stream(see\n        //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know\n        //   where they're going to store the final result, so they'll have to capture this data themselves\n        if (req.body !== undefined) {\n          requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize(req.body));\n        }\n        break;\n      }\n      default: {\n        if ({}.hasOwnProperty.call(req, key)) {\n          requestData[key] = (req )[key];\n        }\n      }\n    }\n  });\n\n  return requestData;\n}\n\n/**\n * Options deciding what parts of the request to use when enhancing an event\n */\n\n/**\n * Add data from the given request to the given event\n *\n * @param event The event to which the request data will be added\n * @param req Request object\n * @param options.include Flags to control what data is included\n * @param options.deps Injected platform-specific dependencies\n * @hidden\n */\nfunction addRequestDataToEvent(\n  event,\n  req,\n  options,\n) {\n  var include = {\n    ...DEFAULT_INCLUDES,\n    ..._optionalChain([options, 'optionalAccess', _ => _.include]),\n  };\n\n  if (include.request) {\n    var extractedRequestData = Array.isArray(include.request)\n      ? extractRequestData(req, { include: include.request, deps: _optionalChain([options, 'optionalAccess', _2 => _2.deps]) })\n      : extractRequestData(req, { deps: _optionalChain([options, 'optionalAccess', _3 => _3.deps]) });\n\n    event.request = {\n      ...event.request,\n      ...extractedRequestData,\n    };\n  }\n\n  if (include.user) {\n    var extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};\n\n    if (Object.keys(extractedUser).length) {\n      event.user = {\n        ...event.user,\n        ...extractedUser,\n      };\n    }\n  }\n\n  // client ip:\n  //   node, nextjs: req.socket.remoteAddress\n  //   express, koa: req.ip\n  if (include.ip) {\n    var ip = req.ip || (req.socket && req.socket.remoteAddress);\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n\n  if (include.transaction && !event.transaction) {\n    // TODO do we even need this anymore?\n    // TODO make this work for nextjs\n    event.transaction = extractTransaction(req, include.transaction);\n  }\n\n  return event;\n}\n\nfunction extractQueryParams(\n  req,\n  deps,\n) {\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  let originalUrl = req.originalUrl || req.url || '';\n\n  if (!originalUrl) {\n    return;\n  }\n\n  // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n  // hostname on the beginning. Since the point here is just to grab the query string, it doesn't matter what we use.\n  if (originalUrl.startsWith('/')) {\n    originalUrl = `http://dogs.are.great${originalUrl}`;\n  }\n\n  return (\n    req.query ||\n    (typeof URL !== undefined && new URL(originalUrl).search.replace('?', '')) ||\n    // In Node 8, `URL` isn't in the global scope, so we have to use the built-in module from Node\n    (deps && deps.url && deps.url.parse(originalUrl).query) ||\n    undefined\n  );\n}\n\nexport { addRequestDataToEvent, addRequestDataToTransaction, extractPathForTransaction, extractRequestData };\n//# sourceMappingURL=requestdata.js.map\n","import { withScope, captureException } from '@sentry/core';\nimport { getCurrentHub } from '@sentry/hub';\nimport { addExceptionMechanism, addRequestDataToEvent } from '@sentry/utils';\n\n/** Platform-agnostic version of `flush` */\nfunction flush(timeout) {\n  var client = getCurrentHub().getClient();\n  return client ? client.flush(timeout) : Promise.resolve(false);\n}\n\n/**\n * Capture the exception passed by nextjs to the `_error` page, adding context data as appropriate.\n *\n * @param contextOrProps The data passed to either `getInitialProps` or `render` by nextjs\n */\nasync function captureUnderscoreErrorException(contextOrProps) {\n  const { req, res, err } = contextOrProps;\n\n  // 404s (and other 400-y friends) can trigger `_error`, but we don't want to send them to Sentry\n  var statusCode = (res && res.statusCode) || contextOrProps.statusCode;\n  if (statusCode && statusCode < 500) {\n    return Promise.resolve();\n  }\n\n  // In previous versions of the suggested `_error.js` page in which this function is meant to be used, there was a\n  // workaround for https://github.com/vercel/next.js/issues/8592 which involved an extra call to this function, in the\n  // custom error component's `render` method, just in case it hadn't been called by `getInitialProps`. Now that that\n  // issue has been fixed, the second call is unnecessary, but since it lives in user code rather than our code, users\n  // have to be the ones to get rid of it, and guaraneteedly, not all of them will. So, rather than capture the error\n  // twice, we just bail if we sense we're in that now-extraneous second call. (We can tell which function we're in\n  // because Nextjs passes `pathname` to `getInitialProps` but not to `render`.)\n  if (!contextOrProps.pathname) {\n    return Promise.resolve();\n  }\n\n  withScope(scope => {\n    scope.addEventProcessor(event => {\n      addExceptionMechanism(event, {\n        type: 'instrument',\n        handled: true,\n        data: {\n          function: '_error.getInitialProps',\n        },\n      });\n      return event;\n    });\n\n    if (req) {\n      scope.addEventProcessor(event => addRequestDataToEvent(event, req));\n    }\n\n    // If third-party libraries (or users themselves) throw something falsy, we want to capture it as a message (which\n    // is what passing a string to `captureException` will wind up doing)\n    captureException(err || `_error.js called with falsy error (${err})`);\n  });\n\n  // In case this is being run as part of a serverless function (as is the case with the server half of nextjs apps\n  // deployed to vercel), make sure the error gets sent to Sentry before the lambda exits.\n  await flush(2000);\n}\n\nexport { captureUnderscoreErrorException };\n//# sourceMappingURL=_error.js.map\n","import { isNodeEnv } from './node.js';\n\n/** Internal */\n\nvar fallbackGlobalObject = {};\n\n/**\n * Safely get global scope object\n *\n * @returns Global scope object\n */\nfunction getGlobalObject() {\n  return (\n    isNodeEnv()\n      ? global\n      : typeof window !== 'undefined'       ? window       : typeof self !== 'undefined'\n      ? self\n      : fallbackGlobalObject\n  ) ;\n}\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value\n * @returns the singleton\n */\nfunction getGlobalSingleton(name, creator, obj) {\n  var global = (obj || getGlobalObject()) ;\n  var __SENTRY__ = (global.__SENTRY__ = global.__SENTRY__ || {});\n  var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());\n  return singleton;\n}\n\nexport { getGlobalObject, getGlobalSingleton };\n//# sourceMappingURL=global.js.map\n","/*\n * This module exists for optimizations in the build process through rollup and terser.  We define some global\n * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these\n * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will\n * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to\n * `logger` and preventing node-related code from appearing in browser bundles.\n *\n * Attention:\n * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by\n * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)\n * having issues tree-shaking these constants across package boundaries.\n * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want\n * users to be able to shake away expressions that it guards.\n */\n\n/**\n * Figures out if we're building a browser bundle.\n *\n * @returns true if this is a browser bundle build.\n */\nfunction isBrowserBundle() {\n  return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;\n}\n\nexport { isBrowserBundle };\n//# sourceMappingURL=env.js.map\n","import { isBrowserBundle } from './env.js';\n\n/**\n * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,\n * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.\n */\n\n/**\n * Checks whether we're in the Node.js or Browser environment\n *\n * @returns Answer to given question\n */\nfunction isNodeEnv() {\n  // explicitly check for browser bundles as those can be optimized statically\n  // by terser/rollup.\n  return (\n    !isBrowserBundle() &&\n    Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'\n  );\n}\n\n/**\n * Requires a module which is protected against bundler minification.\n *\n * @param request The module path to resolve\n */\nfunction dynamicRequire(mod, request) {\n    return mod.require(request);\n}\n\n/**\n * Helper for dynamically loading module that should work with linked dependencies.\n * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`\n * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during\n * build time. `require.resolve` is also not available in any other way, so we cannot create,\n * a fake helper like we do with `dynamicRequire`.\n *\n * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.\n * That is to mimic the behavior of `require.resolve` exactly.\n *\n * @param moduleName module name to require\n * @returns possibly required module\n */\nfunction loadModule(moduleName) {\n  let mod;\n\n  try {\n    mod = dynamicRequire(module, moduleName);\n  } catch (e) {\n    // no-empty\n  }\n\n  try {\n    const { cwd } = dynamicRequire(module, 'process');\n    mod = dynamicRequire(module, `${cwd()}/node_modules/${moduleName}`) ;\n  } catch (e) {\n    // no-empty\n  }\n\n  return mod;\n}\n\nexport { dynamicRequire, isNodeEnv, loadModule };\n//# sourceMappingURL=node.js.map\n","import { getGlobalObject } from './global.js';\nimport { dynamicRequire, isNodeEnv } from './node.js';\n\n/**\n * An object that can return the current timestamp in seconds since the UNIX epoch.\n */\n\n/**\n * A TimestampSource implementation for environments that do not support the Performance Web API natively.\n *\n * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier\n * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It\n * is more obvious to explain \"why does my span have negative duration\" than \"why my spans have zero duration\".\n */\nvar dateTimestampSource = {\n  nowSeconds: () => Date.now() / 1000,\n};\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction getBrowserPerformance() {\n  const { performance } = getGlobalObject();\n  if (!performance || !performance.now) {\n    return undefined;\n  }\n\n  // Replace performance.timeOrigin with our own timeOrigin based on Date.now().\n  //\n  // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +\n  // performance.now() gives a date arbitrarily in the past.\n  //\n  // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is\n  // undefined.\n  //\n  // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to\n  // interact with data coming out of performance entries.\n  //\n  // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that\n  // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes\n  // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have\n  // observed skews that can be as long as days, weeks or months.\n  //\n  // See https://github.com/getsentry/sentry-javascript/issues/2590.\n  //\n  // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload\n  // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation\n  // transactions of long-lived web pages.\n  var timeOrigin = Date.now() - performance.now();\n\n  return {\n    now: () => performance.now(),\n    timeOrigin,\n  };\n}\n\n/**\n * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't\n * implement the API.\n */\nfunction getNodePerformance() {\n  try {\n    var perfHooks = dynamicRequire(module, 'perf_hooks') ;\n    return perfHooks.performance;\n  } catch (_) {\n    return undefined;\n  }\n}\n\n/**\n * The Performance API implementation for the current platform, if available.\n */\nvar platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();\n\nvar timestampSource =\n  platformPerformance === undefined\n    ? dateTimestampSource\n    : {\n        nowSeconds: () => (platformPerformance.timeOrigin + platformPerformance.now()) / 1000,\n      };\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n */\nvar dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * See `usingPerformanceAPI` to test whether the Performance API is used.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nvar timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);\n\n// Re-exported with an old name for backwards-compatibility.\nvar timestampWithMs = timestampInSeconds;\n\n/**\n * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.\n */\nvar usingPerformanceAPI = platformPerformance !== undefined;\n\n/**\n * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.\n */\nlet _browserPerformanceTimeOriginMode;\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nvar browserPerformanceTimeOrigin = (() => {\n  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n  // data as reliable if they are within a reasonable threshold of the current time.\n\n  const { performance } = getGlobalObject();\n  if (!performance || !performance.now) {\n    _browserPerformanceTimeOriginMode = 'none';\n    return undefined;\n  }\n\n  var threshold = 3600 * 1000;\n  var performanceNow = performance.now();\n  var dateNow = Date.now();\n\n  // if timeOrigin isn't available set delta to threshold so it isn't used\n  var timeOriginDelta = performance.timeOrigin\n    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)\n    : threshold;\n  var timeOriginIsReliable = timeOriginDelta < threshold;\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n    var navigationStart = performance.timing && performance.timing.navigationStart;\n  var hasNavigationStart = typeof navigationStart === 'number';\n  // if navigationStart isn't available set delta to threshold so it isn't used\n  var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n  var navigationStartIsReliable = navigationStartDelta < threshold;\n\n  if (timeOriginIsReliable || navigationStartIsReliable) {\n    // Use the more reliable time origin\n    if (timeOriginDelta <= navigationStartDelta) {\n      _browserPerformanceTimeOriginMode = 'timeOrigin';\n      return performance.timeOrigin;\n    } else {\n      _browserPerformanceTimeOriginMode = 'navigationStart';\n      return navigationStart;\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n  _browserPerformanceTimeOriginMode = 'dateNow';\n  return dateNow;\n})();\n\nexport { _browserPerformanceTimeOriginMode, browserPerformanceTimeOrigin, dateTimestampInSeconds, timestampInSeconds, timestampWithMs, usingPerformanceAPI };\n//# sourceMappingURL=time.js.map\n","\"use strict\";\nvar ref, ref1;\nmodule.exports = ((ref = global.process) == null ? void 0 : ref.env) && typeof ((ref1 = global.process) == null ? void 0 : ref1.env) === \"object\" ? global.process : require(\"../../compiled/process\");\n\n//# sourceMappingURL=process.js.map","(function(){var e={308:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(308);module.exports=r})();","module.exports = require('./dist/pages/_error')\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n","(self[\"webpackChunk_N_E\"] = self[\"webpackChunk_N_E\"] || []).push([[676],{\n\n/***/ 5845:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"u\": function() { return /* binding */ captureUnderscoreErrorException; }\n});\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/global.js\nvar esm_global = __webpack_require__(557);\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/misc.js\n\n\n\n\n/**\n * Extended Window interface that allows for Crypto API usage in IE browsers\n */\n\n/**\n * UUID4 generator\n *\n * @returns string Generated UUID4.\n */\nfunction uuid4() {\n  var global = (0,esm_global/* getGlobalObject */.R)() ;\n  var crypto = (global.crypto || global.msCrypto) ;\n\n  if (crypto && crypto.randomUUID) {\n    return crypto.randomUUID().replace(/-/g, '');\n  }\n\n  var getRandomByte =\n    crypto && crypto.getRandomValues ? () => crypto.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n  // Concatenating the following numbers as strings results in '10000000100040008000100000000000'\n  return (([1e7] ) + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, c =>\n        ((c ) ^ ((getRandomByte() & 15) >> ((c ) / 4))).toString(16),\n  );\n}\n\nfunction getFirstException(event) {\n  return event.exception && event.exception.values ? event.exception.values[0] : undefined;\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nfunction getEventDescription(event) {\n  const { message, event_id: eventId } = event;\n  if (message) {\n    return message;\n  }\n\n  var firstException = getFirstException(event);\n  if (firstException) {\n    if (firstException.type && firstException.value) {\n      return `${firstException.type}: ${firstException.value}`;\n    }\n    return firstException.type || firstException.value || eventId || '<unknown>';\n  }\n  return eventId || '<unknown>';\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */\nfunction addExceptionTypeValue(event, value, type) {\n  var exception = (event.exception = event.exception || {});\n  var values = (exception.values = exception.values || []);\n  var firstException = (values[0] = values[0] || {});\n  if (!firstException.value) {\n    firstException.value = value || '';\n  }\n  if (!firstException.type) {\n    firstException.type = type || 'Error';\n  }\n}\n\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */\nfunction addExceptionMechanism(event, newMechanism) {\n  var firstException = getFirstException(event);\n  if (!firstException) {\n    return;\n  }\n\n  var defaultMechanism = { type: 'generic', handled: true };\n  var currentMechanism = firstException.mechanism;\n  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };\n\n  if (newMechanism && 'data' in newMechanism) {\n    var mergedData = { ...(currentMechanism && currentMechanism.data), ...newMechanism.data };\n    firstException.mechanism.data = mergedData;\n  }\n}\n\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nvar SEMVER_REGEXP =\n  /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n\n/**\n * Represents Semantic Versioning object\n */\n\n/**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */\nfunction parseSemver(input) {\n  var match = input.match(SEMVER_REGEXP) || [];\n  var major = parseInt(match[1], 10);\n  var minor = parseInt(match[2], 10);\n  var patch = parseInt(match[3], 10);\n  return {\n    buildmetadata: match[5],\n    major: isNaN(major) ? undefined : major,\n    minor: isNaN(minor) ? undefined : minor,\n    patch: isNaN(patch) ? undefined : patch,\n    prerelease: match[4],\n  };\n}\n\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */\nfunction addContextToFrame(lines, frame, linesOfContext = 5) {\n  var lineno = frame.lineno || 0;\n  var maxLines = lines.length;\n  var sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);\n\n  frame.pre_context = lines\n    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)\n    .map((line) => snipLine(line, 0));\n\n  frame.context_line = snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);\n\n  frame.post_context = lines\n    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)\n    .map((line) => snipLine(line, 0));\n}\n\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */\nfunction checkOrSetAlreadyCaught(exception) {\n    if (exception && (exception ).__sentry_captured__) {\n    return true;\n  }\n\n  try {\n    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n    // `ExtraErrorData` integration\n    addNonEnumerableProperty(exception , '__sentry_captured__', true);\n  } catch (err) {\n    // `exception` is a primitive, so we can't mark it seen\n  }\n\n  return false;\n}\n\n/**\n * Checks whether the given input is already an array, and if it isn't, wraps it in one.\n *\n * @param maybeArray Input to turn into an array, if necessary\n * @returns The input, if already an array, or an array with the input as the only element, if not\n */\nfunction arrayify(maybeArray) {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n}\n\n\n//# sourceMappingURL=misc.js.map\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/time.js\nvar time = __webpack_require__(7117);\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/logger.js\n\n\n// TODO: Implement different loggers for different environments\nvar global = (0,esm_global/* getGlobalObject */.R)();\n\n/** Prefix for logging strings */\nvar PREFIX = 'Sentry Logger ';\n\nvar CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert', 'trace'] ;\n\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nfunction consoleSandbox(callback) {\n  var global = (0,esm_global/* getGlobalObject */.R)();\n\n  if (!('console' in global)) {\n    return callback();\n  }\n\n  var originalConsole = global.console ;\n  var wrappedLevels = {};\n\n  // Restore all wrapped console methods\n  CONSOLE_LEVELS.forEach(level => {\n    // TODO(v7): Remove this check as it's only needed for Node 6\n    var originalWrappedFunc =\n      originalConsole[level] && (originalConsole[level] ).__sentry_original__;\n    if (level in global.console && originalWrappedFunc) {\n      wrappedLevels[level] = originalConsole[level] ;\n      originalConsole[level] = originalWrappedFunc ;\n    }\n  });\n\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    Object.keys(wrappedLevels).forEach(level => {\n      originalConsole[level] = wrappedLevels[level ];\n    });\n  }\n}\n\nfunction makeLogger() {\n  let enabled = false;\n  var logger = {\n    enable: () => {\n      enabled = true;\n    },\n    disable: () => {\n      enabled = false;\n    },\n  };\n\n  if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n    CONSOLE_LEVELS.forEach(name => {\n            logger[name] = (...args) => {\n        if (enabled) {\n          consoleSandbox(() => {\n            global.console[name](`${PREFIX}[${name}]:`, ...args);\n          });\n        }\n      };\n    });\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      logger[name] = () => undefined;\n    });\n  }\n\n  return logger ;\n}\n\n// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used\nlet logger;\nif ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n  logger = (0,esm_global/* getGlobalSingleton */.Y)('logger', makeLogger);\n} else {\n  logger = makeLogger();\n}\n\n\n//# sourceMappingURL=logger.js.map\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/node.js + 1 modules\nvar node = __webpack_require__(7290);\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/is.js\nvar objectToString = Object.prototype.toString;\n\n/**\n * Checks whether given value's type is one of a few Error or Error-like\n * {@link isError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isError(wat) {\n  switch (objectToString.call(wat)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n      return true;\n    default:\n      return isInstanceOf(wat, Error);\n  }\n}\n/**\n * Checks whether given value is an instance of the given built-in class.\n *\n * @param wat The value to be checked\n * @param className\n * @returns A boolean representing the result.\n */\nfunction isBuiltin(wat, className) {\n  return objectToString.call(wat) === `[object ${className}]`;\n}\n\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isErrorEvent(wat) {\n  return isBuiltin(wat, 'ErrorEvent');\n}\n\n/**\n * Checks whether given value's type is DOMError\n * {@link isDOMError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMError(wat) {\n  return isBuiltin(wat, 'DOMError');\n}\n\n/**\n * Checks whether given value's type is DOMException\n * {@link isDOMException}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMException(wat) {\n  return isBuiltin(wat, 'DOMException');\n}\n\n/**\n * Checks whether given value's type is a string\n * {@link isString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isString(wat) {\n  return isBuiltin(wat, 'String');\n}\n\n/**\n * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)\n * {@link isPrimitive}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction is_isPrimitive(wat) {\n  return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');\n}\n\n/**\n * Checks whether given value's type is an object literal\n * {@link isPlainObject}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPlainObject(wat) {\n  return isBuiltin(wat, 'Object');\n}\n\n/**\n * Checks whether given value's type is an Event instance\n * {@link isEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isEvent(wat) {\n  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\n}\n\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isElement(wat) {\n  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\n}\n\n/**\n * Checks whether given value's type is an regexp\n * {@link isRegExp}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isRegExp(wat) {\n  return isBuiltin(wat, 'RegExp');\n}\n\n/**\n * Checks whether given value has a then function.\n * @param wat A value to be checked.\n */\nfunction isThenable(wat) {\n    return Boolean(wat && wat.then && typeof wat.then === 'function');\n}\n\n/**\n * Checks whether given value's type is a SyntheticEvent\n * {@link isSyntheticEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isSyntheticEvent(wat) {\n  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;\n}\n\n/**\n * Checks whether given value is NaN\n * {@link isNaN}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction is_isNaN(wat) {\n  return typeof wat === 'number' && wat !== wat;\n}\n\n/**\n * Checks whether given value's type is an instance of provided constructor.\n * {@link isInstanceOf}.\n *\n * @param wat A value to be checked.\n * @param base A constructor to be used in a check.\n * @returns A boolean representing the result.\n */\nfunction isInstanceOf(wat, base) {\n  try {\n    return wat instanceof base;\n  } catch (_e) {\n    return false;\n  }\n}\n\n\n//# sourceMappingURL=is.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/syncpromise.js\n\n\n/** SyncPromise internal states */\nvar States; (function (States) {\n  /** Pending */\n  var PENDING = 0; States[States[\"PENDING\"] = PENDING] = \"PENDING\";\n  /** Resolved / OK */\n  var RESOLVED = 1; States[States[\"RESOLVED\"] = RESOLVED] = \"RESOLVED\";\n  /** Rejected / Error */\n  var REJECTED = 2; States[States[\"REJECTED\"] = REJECTED] = \"REJECTED\";\n})(States || (States = {}));\n\n// Overloads so we can call resolvedSyncPromise without arguments and generic argument\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nfunction resolvedSyncPromise(value) {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nfunction rejectedSyncPromise(reason) {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nclass SyncPromise {\n   __init() {this._state = States.PENDING;}\n   __init2() {this._handlers = [];}\n  \n\n   constructor(\n    executor,\n  ) {;SyncPromise.prototype.__init.call(this);SyncPromise.prototype.__init2.call(this);SyncPromise.prototype.__init3.call(this);SyncPromise.prototype.__init4.call(this);SyncPromise.prototype.__init5.call(this);SyncPromise.prototype.__init6.call(this);\n    try {\n      executor(this._resolve, this._reject);\n    } catch (e) {\n      this._reject(e);\n    }\n  }\n\n  /** JSDoc */\n   then(\n    onfulfilled,\n    onrejected,\n  ) {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([\n        false,\n        result => {\n          if (!onfulfilled) {\n            // TODO: ¯\\_(ツ)_/¯\n            // TODO: FIXME\n            resolve(result );\n          } else {\n            try {\n              resolve(onfulfilled(result));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n        reason => {\n          if (!onrejected) {\n            reject(reason);\n          } else {\n            try {\n              resolve(onrejected(reason));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n      ]);\n      this._executeHandlers();\n    });\n  }\n\n  /** JSDoc */\n   catch(\n    onrejected,\n  ) {\n    return this.then(val => val, onrejected);\n  }\n\n  /** JSDoc */\n   finally(onfinally) {\n    return new SyncPromise((resolve, reject) => {\n      let val;\n      let isRejected;\n\n      return this.then(\n        value => {\n          isRejected = false;\n          val = value;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n        reason => {\n          isRejected = true;\n          val = reason;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n      ).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val );\n      });\n    });\n  }\n\n  /** JSDoc */\n    __init3() {this._resolve = (value) => {\n    this._setResult(States.RESOLVED, value);\n  };}\n\n  /** JSDoc */\n    __init4() {this._reject = (reason) => {\n    this._setResult(States.REJECTED, reason);\n  };}\n\n  /** JSDoc */\n    __init5() {this._setResult = (state, value) => {\n    if (this._state !== States.PENDING) {\n      return;\n    }\n\n    if (isThenable(value)) {\n      void (value ).then(this._resolve, this._reject);\n      return;\n    }\n\n    this._state = state;\n    this._value = value;\n\n    this._executeHandlers();\n  };}\n\n  /** JSDoc */\n    __init6() {this._executeHandlers = () => {\n    if (this._state === States.PENDING) {\n      return;\n    }\n\n    var cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n\n      if (this._state === States.RESOLVED) {\n                handler[1](this._value );\n      }\n\n      if (this._state === States.REJECTED) {\n        handler[2](this._value);\n      }\n\n      handler[0] = true;\n    });\n  };}\n}\n\n\n//# sourceMappingURL=syncpromise.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/browser.js\n\n\n\n/**\n * Given a child DOM element, returns a query-selector statement describing that\n * and its ancestors\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction htmlTreeAsString(elem, keyAttrs) {\n  \n\n  // try/catch both:\n  // - accessing event.target (see getsentry/raven-js#838, #768)\n  // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\n  // - can throw an exception in some circumstances.\n  try {\n    let currentElem = elem ;\n    var MAX_TRAVERSE_HEIGHT = 5;\n    var MAX_OUTPUT_LEN = 80;\n    var out = [];\n    let height = 0;\n    let len = 0;\n    var separator = ' > ';\n    var sepLength = separator.length;\n    let nextStr;\n\n        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {\n      nextStr = _htmlElementAsString(currentElem, keyAttrs);\n      // bail out if\n      // - nextStr is the 'html' element\n      // - the length of the string that would be created exceeds MAX_OUTPUT_LEN\n      //   (ignore this limit if we are on the first iteration)\n      if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {\n        break;\n      }\n\n      out.push(nextStr);\n\n      len += nextStr.length;\n      currentElem = currentElem.parentNode;\n    }\n\n    return out.reverse().join(separator);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/**\n * Returns a simple, query-selector representation of a DOM element\n * e.g. [HTMLElement] => input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction _htmlElementAsString(el, keyAttrs) {\n  var elem = el \n\n;\n\n  var out = [];\n  let className;\n  let classes;\n  let key;\n  let attr;\n  let i;\n\n  if (!elem || !elem.tagName) {\n    return '';\n  }\n\n  out.push(elem.tagName.toLowerCase());\n\n  // Pairs of attribute keys defined in `serializeAttribute` and their values on element.\n  var keyAttrPairs =\n    keyAttrs && keyAttrs.length\n      ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])\n      : null;\n\n  if (keyAttrPairs && keyAttrPairs.length) {\n    keyAttrPairs.forEach(keyAttrPair => {\n      out.push(`[${keyAttrPair[0]}=\"${keyAttrPair[1]}\"]`);\n    });\n  } else {\n    if (elem.id) {\n      out.push(`#${elem.id}`);\n    }\n\n        className = elem.className;\n    if (className && isString(className)) {\n      classes = className.split(/\\s+/);\n      for (i = 0; i < classes.length; i++) {\n        out.push(`.${classes[i]}`);\n      }\n    }\n  }\n  var allowedAttrs = ['type', 'name', 'title', 'alt'];\n  for (i = 0; i < allowedAttrs.length; i++) {\n    key = allowedAttrs[i];\n    attr = elem.getAttribute(key);\n    if (attr) {\n      out.push(`[${key}=\"${attr}\"]`);\n    }\n  }\n  return out.join('');\n}\n\n/**\n * A safe form of location.href\n */\nfunction getLocationHref() {\n  var global = getGlobalObject();\n  try {\n    return global.document.location.href;\n  } catch (oO) {\n    return '';\n  }\n}\n\n/**\n * Gets a DOM element by using document.querySelector.\n *\n * This wrapper will first check for the existance of the function before\n * actually calling it so that we don't have to take care of this check,\n * every time we want to access the DOM.\n *\n * Reason: DOM/querySelector is not available in all environments.\n *\n * We have to cast to any because utils can be consumed by a variety of environments,\n * and we don't want to break TS users. If you know what element will be selected by\n * `document.querySelector`, specify it as part of the generic call. For example,\n * `var element = getDomElement<Element>('selector');`\n *\n * @param selector the selector string passed on to document.querySelector\n */\nfunction getDomElement(selector) {\n  var global = getGlobalObject();\n  if (global.document && global.document.querySelector) {\n    return global.document.querySelector(selector) ;\n  }\n  return null;\n}\n\n\n//# sourceMappingURL=browser.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/object.js\n\n\n\n\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */\nfunction fill(source, name, replacementFactory) {\n  if (!(name in source)) {\n    return;\n  }\n\n  var original = source[name] ;\n  var wrapped = replacementFactory(original) ;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    try {\n      markFunctionWrapped(wrapped, original);\n    } catch (_Oo) {\n      // This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n\n  source[name] = wrapped;\n}\n\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */\nfunction object_addNonEnumerableProperty(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n    value: value,\n    writable: true,\n    configurable: true,\n  });\n}\n\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */\nfunction markFunctionWrapped(wrapped, original) {\n  var proto = original.prototype || {};\n  wrapped.prototype = original.prototype = proto;\n  object_addNonEnumerableProperty(wrapped, '__sentry_original__', original);\n}\n\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */\nfunction getOriginalFunction(func) {\n  return func.__sentry_original__;\n}\n\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\nfunction urlEncode(object) {\n  return Object.keys(object)\n    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)\n    .join('&');\n}\n\n/**\n * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their\n * non-enumerable properties attached.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n * @returns An Event or Error turned into an object - or the value argurment itself, when value is neither an Event nor\n *  an Error.\n */\nfunction convertToPlainObject(\n  value,\n)\n\n {\n  if (isError(value)) {\n    return {\n      message: value.message,\n      name: value.name,\n      stack: value.stack,\n      ...getOwnProperties(value),\n    };\n  } else if (isEvent(value)) {\n    var newObj\n\n = {\n      type: value.type,\n      target: serializeEventTarget(value.target),\n      currentTarget: serializeEventTarget(value.currentTarget),\n      ...getOwnProperties(value),\n    };\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      newObj.detail = value.detail;\n    }\n\n    return newObj;\n  } else {\n    return value;\n  }\n}\n\n/** Creates a string representation of the target of an `Event` object */\nfunction serializeEventTarget(target) {\n  try {\n    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/** Filters out all but an object's own properties */\nfunction getOwnProperties(obj) {\n  if (typeof obj === 'object' && obj !== null) {\n    var extractedProps = {};\n    for (var property in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, property)) {\n        extractedProps[property] = (obj )[property];\n      }\n    }\n    return extractedProps;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\nfunction extractExceptionKeysForMessage(exception, maxLength = 40) {\n  var keys = Object.keys(convertToPlainObject(exception));\n  keys.sort();\n\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n\n  if (keys[0].length >= maxLength) {\n    return truncate(keys[0], maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    var serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return a new object having removed all fields whose value was `undefined`.\n * Works recursively on objects and arrays.\n *\n * Attention: This function keeps circular references in the returned object.\n */\nfunction dropUndefinedKeys(inputValue) {\n  // This map keeps track of what already visited nodes map to.\n  // Our Set - based memoBuilder doesn't work here because we want to the output object to have the same circular\n  // references as the input object.\n  var memoizationMap = new Map();\n\n  // This function just proxies `_dropUndefinedKeys` to keep the `memoBuilder` out of this function's API\n  return _dropUndefinedKeys(inputValue, memoizationMap);\n}\n\nfunction _dropUndefinedKeys(inputValue, memoizationMap) {\n  if (isPlainObject(inputValue)) {\n    // If this node has already been visited due to a circular reference, return the object it was mapped to in the new object\n    var memoVal = memoizationMap.get(inputValue);\n    if (memoVal !== undefined) {\n      return memoVal ;\n    }\n\n    var returnValue = {};\n    // Store the mapping of this value in case we visit it again, in case of circular data\n    memoizationMap.set(inputValue, returnValue);\n\n    for (var key of Object.keys(inputValue)) {\n      if (typeof inputValue[key] !== 'undefined') {\n        returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);\n      }\n    }\n\n    return returnValue ;\n  }\n\n  if (Array.isArray(inputValue)) {\n    // If this node has already been visited due to a circular reference, return the array it was mapped to in the new object\n    var memoVal = memoizationMap.get(inputValue);\n    if (memoVal !== undefined) {\n      return memoVal ;\n    }\n\n    var returnValue = [];\n    // Store the mapping of this value in case we visit it again, in case of circular data\n    memoizationMap.set(inputValue, returnValue);\n\n    inputValue.forEach((item) => {\n      returnValue.push(_dropUndefinedKeys(item, memoizationMap));\n    });\n\n    return returnValue ;\n  }\n\n  return inputValue;\n}\n\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */\nfunction objectify(wat) {\n  let objectified;\n  switch (true) {\n    case wat === undefined || wat === null:\n      objectified = new String(wat);\n      break;\n\n    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n    // an object in order to wrap it.\n    case typeof wat === 'symbol' || typeof wat === 'bigint':\n      objectified = Object(wat);\n      break;\n\n    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n    case isPrimitive(wat):\n            objectified = new (wat ).constructor(wat);\n      break;\n\n    // by process of elimination, at this point we know that `wat` must already be an object\n    default:\n      objectified = wat;\n      break;\n  }\n  return objectified;\n}\n\n\n//# sourceMappingURL=object.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+hub@7.12.1/node_modules/@sentry/hub/esm/session.js\n\n\n/**\n * Creates a new `Session` object by setting certain default parameters. If optional @param context\n * is passed, the passed properties are applied to the session object.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns a new `Session` object\n */\nfunction makeSession(context) {\n  // Both timestamp and started are in seconds since the UNIX epoch.\n  var startingTime = (0,time/* timestampInSeconds */.ph)();\n\n  var session = {\n    sid: uuid4(),\n    init: true,\n    timestamp: startingTime,\n    started: startingTime,\n    duration: 0,\n    status: 'ok',\n    errors: 0,\n    ignoreDuration: false,\n    toJSON: () => sessionToJSON(session),\n  };\n\n  if (context) {\n    updateSession(session, context);\n  }\n\n  return session;\n}\n\n/**\n * Updates a session object with the properties passed in the context.\n *\n * Note that this function mutates the passed object and returns void.\n * (Had to do this instead of returning a new and updated session because closing and sending a session\n * makes an update to the session after it was passed to the sending logic.\n * @see BaseClient.captureSession )\n *\n * @param session the `Session` to update\n * @param context the `SessionContext` holding the properties that should be updated in @param session\n */\nfunction updateSession(session, context = {}) {\n  if (context.user) {\n    if (!session.ipAddress && context.user.ip_address) {\n      session.ipAddress = context.user.ip_address;\n    }\n\n    if (!session.did && !context.did) {\n      session.did = context.user.id || context.user.email || context.user.username;\n    }\n  }\n\n  session.timestamp = context.timestamp || (0,time/* timestampInSeconds */.ph)();\n\n  if (context.ignoreDuration) {\n    session.ignoreDuration = context.ignoreDuration;\n  }\n  if (context.sid) {\n    // Good enough uuid validation. — Kamil\n    session.sid = context.sid.length === 32 ? context.sid : uuid4();\n  }\n  if (context.init !== undefined) {\n    session.init = context.init;\n  }\n  if (!session.did && context.did) {\n    session.did = `${context.did}`;\n  }\n  if (typeof context.started === 'number') {\n    session.started = context.started;\n  }\n  if (session.ignoreDuration) {\n    session.duration = undefined;\n  } else if (typeof context.duration === 'number') {\n    session.duration = context.duration;\n  } else {\n    var duration = session.timestamp - session.started;\n    session.duration = duration >= 0 ? duration : 0;\n  }\n  if (context.release) {\n    session.release = context.release;\n  }\n  if (context.environment) {\n    session.environment = context.environment;\n  }\n  if (!session.ipAddress && context.ipAddress) {\n    session.ipAddress = context.ipAddress;\n  }\n  if (!session.userAgent && context.userAgent) {\n    session.userAgent = context.userAgent;\n  }\n  if (typeof context.errors === 'number') {\n    session.errors = context.errors;\n  }\n  if (context.status) {\n    session.status = context.status;\n  }\n}\n\n/**\n * Closes a session by setting its status and updating the session object with it.\n * Internally calls `updateSession` to update the passed session object.\n *\n * Note that this function mutates the passed session (@see updateSession for explanation).\n *\n * @param session the `Session` object to be closed\n * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,\n *               this function will keep the previously set status, unless it was `'ok'` in which case\n *               it is changed to `'exited'`.\n */\nfunction closeSession(session, status) {\n  let context = {};\n  if (status) {\n    context = { status };\n  } else if (session.status === 'ok') {\n    context = { status: 'exited' };\n  }\n\n  updateSession(session, context);\n}\n\n/**\n * Serializes a passed session object to a JSON object with a slightly different structure.\n * This is necessary because the Sentry backend requires a slightly different schema of a session\n * than the one the JS SDKs use internally.\n *\n * @param session the session to be converted\n *\n * @returns a JSON object of the passed session\n */\nfunction sessionToJSON(session) {\n  return dropUndefinedKeys({\n    sid: `${session.sid}`,\n    init: session.init,\n    // Make sure that sec is converted to ms for date constructor\n    started: new Date(session.started * 1000).toISOString(),\n    timestamp: new Date(session.timestamp * 1000).toISOString(),\n    status: session.status,\n    errors: session.errors,\n    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,\n    duration: session.duration,\n    attrs: {\n      release: session.release,\n      environment: session.environment,\n      ip_address: session.ipAddress,\n      user_agent: session.userAgent,\n    },\n  });\n}\n\n\n//# sourceMappingURL=session.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+hub@7.12.1/node_modules/@sentry/hub/esm/scope.js\n\n\n\n/**\n * Absolute maximum number of breadcrumbs added to an event.\n * The `maxBreadcrumbs` option cannot be higher than this value.\n */\nvar MAX_BREADCRUMBS = 100;\n\n/**\n * Holds additional event information. {@link Scope.applyToEvent} will be\n * called by the client before an event will be sent.\n */\nclass Scope  {\n  /** Flag if notifying is happening. */\n  \n\n  /** Callback for client to receive scope changes. */\n  \n\n  /** Callback list that will be called after {@link applyToEvent}. */\n  \n\n  /** Array of breadcrumbs. */\n  \n\n  /** User */\n  \n\n  /** Tags */\n  \n\n  /** Extra */\n  \n\n  /** Contexts */\n  \n\n  /** Attachments */\n  \n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n  \n\n  /** Fingerprint */\n  \n\n  /** Severity */\n    \n\n  /** Transaction Name */\n  \n\n  /** Span */\n  \n\n  /** Session */\n  \n\n  /** Request Mode Session Status */\n  \n\n   constructor() {\n    this._notifyingListeners = false;\n    this._scopeListeners = [];\n    this._eventProcessors = [];\n    this._breadcrumbs = [];\n    this._attachments = [];\n    this._user = {};\n    this._tags = {};\n    this._extra = {};\n    this._contexts = {};\n    this._sdkProcessingMetadata = {};\n  }\n\n  /**\n   * Inherit values from the parent scope.\n   * @param scope to clone.\n   */\n   static clone(scope) {\n    var newScope = new Scope();\n    if (scope) {\n      newScope._breadcrumbs = [...scope._breadcrumbs];\n      newScope._tags = { ...scope._tags };\n      newScope._extra = { ...scope._extra };\n      newScope._contexts = { ...scope._contexts };\n      newScope._user = scope._user;\n      newScope._level = scope._level;\n      newScope._span = scope._span;\n      newScope._session = scope._session;\n      newScope._transactionName = scope._transactionName;\n      newScope._fingerprint = scope._fingerprint;\n      newScope._eventProcessors = [...scope._eventProcessors];\n      newScope._requestSession = scope._requestSession;\n      newScope._attachments = [...scope._attachments];\n    }\n    return newScope;\n  }\n\n  /**\n   * Add internal on change listener. Used for sub SDKs that need to store the scope.\n   * @hidden\n   */\n   addScopeListener(callback) {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addEventProcessor(callback) {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setUser(user) {\n    this._user = user || {};\n    if (this._session) {\n      updateSession(this._session, { user });\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getUser() {\n    return this._user;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getRequestSession() {\n    return this._requestSession;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setRequestSession(requestSession) {\n    this._requestSession = requestSession;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTags(tags) {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTag(key, value) {\n    this._tags = { ...this._tags, [key]: value };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtras(extras) {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtra(key, extra) {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setFingerprint(fingerprint) {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setLevel(\n        level,\n  ) {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTransactionName(name) {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setContext(key, context) {\n    if (context === null) {\n            delete this._contexts[key];\n    } else {\n      this._contexts = { ...this._contexts, [key]: context };\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setSpan(span) {\n    this._span = span;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getSpan() {\n    return this._span;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getTransaction() {\n    // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will\n    // have a pointer to the currently-active transaction.\n    var span = this.getSpan();\n    return span && span.transaction;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setSession(session) {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getSession() {\n    return this._session;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   update(captureContext) {\n    if (!captureContext) {\n      return this;\n    }\n\n    if (typeof captureContext === 'function') {\n      var updatedScope = (captureContext )(this);\n      return updatedScope instanceof Scope ? updatedScope : this;\n    }\n\n    if (captureContext instanceof Scope) {\n      this._tags = { ...this._tags, ...captureContext._tags };\n      this._extra = { ...this._extra, ...captureContext._extra };\n      this._contexts = { ...this._contexts, ...captureContext._contexts };\n      if (captureContext._user && Object.keys(captureContext._user).length) {\n        this._user = captureContext._user;\n      }\n      if (captureContext._level) {\n        this._level = captureContext._level;\n      }\n      if (captureContext._fingerprint) {\n        this._fingerprint = captureContext._fingerprint;\n      }\n      if (captureContext._requestSession) {\n        this._requestSession = captureContext._requestSession;\n      }\n    } else if (isPlainObject(captureContext)) {\n            captureContext = captureContext ;\n      this._tags = { ...this._tags, ...captureContext.tags };\n      this._extra = { ...this._extra, ...captureContext.extra };\n      this._contexts = { ...this._contexts, ...captureContext.contexts };\n      if (captureContext.user) {\n        this._user = captureContext.user;\n      }\n      if (captureContext.level) {\n        this._level = captureContext.level;\n      }\n      if (captureContext.fingerprint) {\n        this._fingerprint = captureContext.fingerprint;\n      }\n      if (captureContext.requestSession) {\n        this._requestSession = captureContext.requestSession;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clear() {\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._requestSession = undefined;\n    this._span = undefined;\n    this._session = undefined;\n    this._notifyScopeListeners();\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addBreadcrumb(breadcrumb, maxBreadcrumbs) {\n    var maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    var mergedBreadcrumb = {\n      timestamp: (0,time/* dateTimestampInSeconds */.yW)(),\n      ...breadcrumb,\n    };\n    this._breadcrumbs = [...this._breadcrumbs, mergedBreadcrumb].slice(-maxCrumbs);\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clearBreadcrumbs() {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addAttachment(attachment) {\n    this._attachments.push(attachment);\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getAttachments() {\n    return this._attachments;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clearAttachments() {\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * Applies data from the scope to the event and runs all event processors on it.\n   *\n   * @param event Event\n   * @param hint Object containing additional information about the original exception, for use by the event processors.\n   * @hidden\n   */\n   applyToEvent(event, hint = {}) {\n    if (this._extra && Object.keys(this._extra).length) {\n      event.extra = { ...this._extra, ...event.extra };\n    }\n    if (this._tags && Object.keys(this._tags).length) {\n      event.tags = { ...this._tags, ...event.tags };\n    }\n    if (this._user && Object.keys(this._user).length) {\n      event.user = { ...this._user, ...event.user };\n    }\n    if (this._contexts && Object.keys(this._contexts).length) {\n      event.contexts = { ...this._contexts, ...event.contexts };\n    }\n    if (this._level) {\n      event.level = this._level;\n    }\n    if (this._transactionName) {\n      event.transaction = this._transactionName;\n    }\n\n    // We want to set the trace context for normal events only if there isn't already\n    // a trace context on the event. There is a product feature in place where we link\n    // errors with transaction and it relies on that.\n    if (this._span) {\n      event.contexts = { trace: this._span.getTraceContext(), ...event.contexts };\n      var transactionName = this._span.transaction && this._span.transaction.name;\n      if (transactionName) {\n        event.tags = { transaction: transactionName, ...event.tags };\n      }\n    }\n\n    this._applyFingerprint(event);\n\n    event.breadcrumbs = [...(event.breadcrumbs || []), ...this._breadcrumbs];\n    event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;\n\n    event.sdkProcessingMetadata = { ...event.sdkProcessingMetadata, ...this._sdkProcessingMetadata };\n\n    return this._notifyEventProcessors([...getGlobalEventProcessors(), ...this._eventProcessors], event, hint);\n  }\n\n  /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry\n   */\n   setSDKProcessingMetadata(newData) {\n    this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };\n\n    return this;\n  }\n\n  /**\n   * This will be called after {@link applyToEvent} is finished.\n   */\n   _notifyEventProcessors(\n    processors,\n    event,\n    hint,\n    index = 0,\n  ) {\n    return new SyncPromise((resolve, reject) => {\n      var processor = processors[index];\n      if (event === null || typeof processor !== 'function') {\n        resolve(event);\n      } else {\n        var result = processor({ ...event }, hint) ;\n\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n          processor.id &&\n          result === null &&\n          logger.log(`Event processor \"${processor.id}\" dropped event`);\n\n        if (isThenable(result)) {\n          void result\n            .then(final => this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve))\n            .then(null, reject);\n        } else {\n          void this._notifyEventProcessors(processors, result, hint, index + 1)\n            .then(resolve)\n            .then(null, reject);\n        }\n      }\n    });\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n   _notifyScopeListeners() {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n\n  /**\n   * Applies fingerprint from the scope to the event if there's one,\n   * uses message if there's one instead or get rid of empty fingerprint\n   */\n   _applyFingerprint(event) {\n    // Make sure it's an array first and we actually have something in place\n    event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];\n\n    // If we have something on the scope, then merge it with event\n    if (this._fingerprint) {\n      event.fingerprint = event.fingerprint.concat(this._fingerprint);\n    }\n\n    // If we have no data at all, remove empty array default\n    if (event.fingerprint && !event.fingerprint.length) {\n      delete event.fingerprint;\n    }\n  }\n}\n\n/**\n * Returns the global event processors.\n */\nfunction getGlobalEventProcessors() {\n  return (0,esm_global/* getGlobalSingleton */.Y)('globalEventProcessors', () => []);\n}\n\n/**\n * Add a EventProcessor to be kept globally.\n * @param callback EventProcessor to add\n */\nfunction addGlobalEventProcessor(callback) {\n  getGlobalEventProcessors().push(callback);\n}\n\n\n//# sourceMappingURL=scope.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+hub@7.12.1/node_modules/@sentry/hub/esm/hub.js\n\n\n\n\n/**\n * API compatibility version of this hub.\n *\n * WARNING: This number should only be increased when the global interface\n * changes and new methods are introduced.\n *\n * @hidden\n */\nvar API_VERSION = 4;\n\n/**\n * Default maximum number of breadcrumbs added to an event. Can be overwritten\n * with {@link Options.maxBreadcrumbs}.\n */\nvar DEFAULT_BREADCRUMBS = 100;\n\n/**\n * A layer in the process stack.\n * @hidden\n */\n\n/**\n * @inheritDoc\n */\nclass Hub  {\n  /** Is a {@link Layer}[] containing the client and scope */\n    __init() {this._stack = [{}];}\n\n  /** Contains the last event id of a captured event.  */\n  \n\n  /**\n   * Creates a new instance of the hub, will push one {@link Layer} into the\n   * internal stack on creation.\n   *\n   * @param client bound to the hub.\n   * @param scope bound to the hub.\n   * @param version number, higher number means higher priority.\n   */\n   constructor(client, scope = new Scope(),   _version = API_VERSION) {;this._version = _version;Hub.prototype.__init.call(this);\n    this.getStackTop().scope = scope;\n    if (client) {\n      this.bindClient(client);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   isOlderThan(version) {\n    return this._version < version;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   bindClient(client) {\n    var top = this.getStackTop();\n    top.client = client;\n    if (client && client.setupIntegrations) {\n      client.setupIntegrations();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   pushScope() {\n    // We want to clone the content of prev scope\n    var scope = Scope.clone(this.getScope());\n    this.getStack().push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   popScope() {\n    if (this.getStack().length <= 1) return false;\n    return !!this.getStack().pop();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   withScope(callback) {\n    var scope = this.pushScope();\n    try {\n      callback(scope);\n    } finally {\n      this.popScope();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getClient() {\n    return this.getStackTop().client ;\n  }\n\n  /** Returns the scope of the top stack. */\n   getScope() {\n    return this.getStackTop().scope;\n  }\n\n  /** Returns the scope stack for domains or the process. */\n   getStack() {\n    return this._stack;\n  }\n\n  /** Returns the topmost scope layer in the order domain > local > process. */\n   getStackTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  /**\n   * @inheritDoc\n   */\n     captureException(exception, hint) {\n    var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());\n    var syntheticException = new Error('Sentry syntheticException');\n    this._withClient((client, scope) => {\n      client.captureException(\n        exception,\n        {\n          originalException: exception,\n          syntheticException,\n          ...hint,\n          event_id: eventId,\n        },\n        scope,\n      );\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureMessage(\n    message,\n        level,\n    hint,\n  ) {\n    var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());\n    var syntheticException = new Error(message);\n    this._withClient((client, scope) => {\n      client.captureMessage(\n        message,\n        level,\n        {\n          originalException: message,\n          syntheticException,\n          ...hint,\n          event_id: eventId,\n        },\n        scope,\n      );\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint) {\n    var eventId = hint && hint.event_id ? hint.event_id : uuid4();\n    if (event.type !== 'transaction') {\n      this._lastEventId = eventId;\n    }\n\n    this._withClient((client, scope) => {\n      client.captureEvent(event, { ...hint, event_id: eventId }, scope);\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   lastEventId() {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addBreadcrumb(breadcrumb, hint) {\n    const { scope, client } = this.getStackTop();\n\n    if (!scope || !client) return;\n\n        const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } =\n      (client.getOptions && client.getOptions()) || {};\n\n    if (maxBreadcrumbs <= 0) return;\n\n    var timestamp = (0,time/* dateTimestampInSeconds */.yW)();\n    var mergedBreadcrumb = { timestamp, ...breadcrumb };\n    var finalBreadcrumb = beforeBreadcrumb\n      ? (consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) )\n      : mergedBreadcrumb;\n\n    if (finalBreadcrumb === null) return;\n\n    scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setUser(user) {\n    var scope = this.getScope();\n    if (scope) scope.setUser(user);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTags(tags) {\n    var scope = this.getScope();\n    if (scope) scope.setTags(tags);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtras(extras) {\n    var scope = this.getScope();\n    if (scope) scope.setExtras(extras);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTag(key, value) {\n    var scope = this.getScope();\n    if (scope) scope.setTag(key, value);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtra(key, extra) {\n    var scope = this.getScope();\n    if (scope) scope.setExtra(key, extra);\n  }\n\n  /**\n   * @inheritDoc\n   */\n     setContext(name, context) {\n    var scope = this.getScope();\n    if (scope) scope.setContext(name, context);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   configureScope(callback) {\n    const { scope, client } = this.getStackTop();\n    if (scope && client) {\n      callback(scope);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   run(callback) {\n    var oldHub = makeMain(this);\n    try {\n      callback(this);\n    } finally {\n      makeMain(oldHub);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getIntegration(integration) {\n    var client = this.getClient();\n    if (!client) return null;\n    try {\n      return client.getIntegration(integration);\n    } catch (_oO) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   startTransaction(context, customSamplingContext) {\n    return this._callExtensionMethod('startTransaction', context, customSamplingContext);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   traceHeaders() {\n    return this._callExtensionMethod('traceHeaders');\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureSession(endSession = false) {\n    // both send the update and pull the session from the scope\n    if (endSession) {\n      return this.endSession();\n    }\n\n    // only send the update\n    this._sendSessionUpdate();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   endSession() {\n    var layer = this.getStackTop();\n    var scope = layer && layer.scope;\n    var session = scope && scope.getSession();\n    if (session) {\n      closeSession(session);\n    }\n    this._sendSessionUpdate();\n\n    // the session is over; take it off of the scope\n    if (scope) {\n      scope.setSession();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   startSession(context) {\n    const { scope, client } = this.getStackTop();\n    const { release, environment } = (client && client.getOptions()) || {};\n\n    // Will fetch userAgent if called from browser sdk\n    var global = (0,esm_global/* getGlobalObject */.R)();\n    const { userAgent } = global.navigator || {};\n\n    var session = makeSession({\n      release,\n      environment,\n      ...(scope && { user: scope.getUser() }),\n      ...(userAgent && { userAgent }),\n      ...context,\n    });\n\n    if (scope) {\n      // End existing session if there's one\n      var currentSession = scope.getSession && scope.getSession();\n      if (currentSession && currentSession.status === 'ok') {\n        updateSession(currentSession, { status: 'exited' });\n      }\n      this.endSession();\n\n      // Afterwards we set the new session on the scope\n      scope.setSession(session);\n    }\n\n    return session;\n  }\n\n  /**\n   * Returns if default PII should be sent to Sentry and propagated in ourgoing requests\n   * when Tracing is used.\n   */\n   shouldSendDefaultPii() {\n    var client = this.getClient();\n    var options = client && client.getOptions();\n    return Boolean(options && options.sendDefaultPii);\n  }\n\n  /**\n   * Sends the current Session on the scope\n   */\n   _sendSessionUpdate() {\n    const { scope, client } = this.getStackTop();\n    if (!scope) return;\n\n    var session = scope.getSession();\n    if (session) {\n      if (client && client.captureSession) {\n        client.captureSession(session);\n      }\n    }\n  }\n\n  /**\n   * Internal helper function to call a method on the top client if it exists.\n   *\n   * @param method The method to call on the client.\n   * @param args Arguments to pass to the client function.\n   */\n   _withClient(callback) {\n    const { scope, client } = this.getStackTop();\n    if (client) {\n      callback(client, scope);\n    }\n  }\n\n  /**\n   * Calls global extension method and binding current instance to the function call\n   */\n  // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)\n     _callExtensionMethod(method, ...args) {\n    var carrier = getMainCarrier();\n    var sentry = carrier.__SENTRY__;\n    if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {\n      return sentry.extensions[method].apply(this, args);\n    }\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);\n  }\n}\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nfunction getMainCarrier() {\n  var carrier = (0,esm_global/* getGlobalObject */.R)();\n  carrier.__SENTRY__ = carrier.__SENTRY__ || {\n    extensions: {},\n    hub: undefined,\n  };\n  return carrier;\n}\n\n/**\n * Replaces the current main hub with the passed one on the global object\n *\n * @returns The old replaced hub\n */\nfunction makeMain(hub) {\n  var registry = getMainCarrier();\n  var oldHub = getHubFromCarrier(registry);\n  setHubOnCarrier(registry, hub);\n  return oldHub;\n}\n\n/**\n * Returns the default hub instance.\n *\n * If a hub is already registered in the global carrier but this module\n * contains a more recent version, it replaces the registered version.\n * Otherwise, the currently registered hub will be returned.\n */\nfunction hub_getCurrentHub() {\n  // Get main carrier (global for every environment)\n  var registry = getMainCarrier();\n\n  // If there's no hub, or its an old API, assign a new one\n  if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {\n    setHubOnCarrier(registry, new Hub());\n  }\n\n  // Prefer domains over global if they are there (applicable only to Node environment)\n  if ((0,node/* isNodeEnv */.KV)()) {\n    return getHubFromActiveDomain(registry);\n  }\n  // Return hub that lives on a global object\n  return getHubFromCarrier(registry);\n}\n\n/**\n * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist\n * @returns discovered hub\n */\nfunction getHubFromActiveDomain(registry) {\n  try {\n    var sentry = getMainCarrier().__SENTRY__;\n    var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;\n\n    // If there's no active domain, just return global hub\n    if (!activeDomain) {\n      return getHubFromCarrier(registry);\n    }\n\n    // If there's no hub on current domain, or it's an old API, assign a new one\n    if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {\n      var registryHubTopStack = getHubFromCarrier(registry).getStackTop();\n      setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));\n    }\n\n    // Return hub that lives on a domain\n    return getHubFromCarrier(activeDomain);\n  } catch (_Oo) {\n    // Return hub that lives on a global object\n    return getHubFromCarrier(registry);\n  }\n}\n\n/**\n * This will tell whether a carrier has a hub on it or not\n * @param carrier object\n */\nfunction hasHubOnCarrier(carrier) {\n  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);\n}\n\n/**\n * This will create a new {@link Hub} and add to the passed object on\n * __SENTRY__.hub.\n * @param carrier object\n * @hidden\n */\nfunction getHubFromCarrier(carrier) {\n  return (0,esm_global/* getGlobalSingleton */.Y)('hub', () => new Hub(), carrier);\n}\n\n/**\n * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute\n * @param carrier object\n * @param hub Hub\n * @returns A boolean indicating success or failure\n */\nfunction setHubOnCarrier(carrier, hub) {\n  if (!carrier) return false;\n  var __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n  __SENTRY__.hub = hub;\n  return true;\n}\n\n\n//# sourceMappingURL=hub.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+hub@7.12.1/node_modules/@sentry/hub/esm/exports.js\n\n\n// Note: All functions in this file are typed with a return value of `ReturnType<Hub[HUB_FUNCTION]>`,\n// where HUB_FUNCTION is some method on the Hub class.\n//\n// This is done to make sure the top level SDK methods stay in sync with the hub methods.\n// Although every method here has an explicit return type, some of them (that map to void returns) do not\n// contain `return` keywords. This is done to save on bundle size, as `return` is not minifiable.\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception An exception-like object.\n * @param captureContext Additional scope data to apply to exception event.\n * @returns The generated eventId.\n */\nfunction captureException(exception, captureContext) {\n  return hub_getCurrentHub().captureException(exception, { captureContext });\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param Severity Define the level of the message.\n * @returns The generated eventId.\n */\nfunction captureMessage(\n  message,\n    captureContext,\n) {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  var level = typeof captureContext === 'string' ? captureContext : undefined;\n  var context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return getCurrentHub().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @returns The generated eventId.\n */\nfunction captureEvent(event, hint) {\n  return getCurrentHub().captureEvent(event, hint);\n}\n\n/**\n * Callback to set context information onto the scope.\n * @param callback Callback function that receives Scope.\n */\nfunction configureScope(callback) {\n  getCurrentHub().configureScope(callback);\n}\n\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user's actions prior to an error or crash.\n *\n * @param breadcrumb The breadcrumb to record.\n */\nfunction addBreadcrumb(breadcrumb) {\n  getCurrentHub().addBreadcrumb(breadcrumb);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nfunction setContext(name, context) {\n  getCurrentHub().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n  getCurrentHub().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n  getCurrentHub().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n  getCurrentHub().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n  getCurrentHub().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n  getCurrentHub().setUser(user);\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n *\n * This is essentially a convenience function for:\n *\n *     pushScope();\n *     callback();\n *     popScope();\n *\n * @param callback that will be enclosed into push/popScope.\n */\nfunction withScope(callback) {\n  hub_getCurrentHub().withScope(callback);\n}\n\n/**\n * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n *\n * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n * new child span within the transaction or any span, call the respective `.startChild()` method.\n *\n * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n *\n * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its\n * finished child spans will be sent to Sentry.\n *\n * NOTE: This function should only be used for *manual* instrumentation. Auto-instrumentation should call\n * `startTransaction` directly on the hub.\n *\n * @param context Properties of the new `Transaction`.\n * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n * default values). See {@link Options.tracesSampler}.\n *\n * @returns The transaction which was just started\n */\nfunction startTransaction(\n  context,\n  customSamplingContext,\n) {\n  return getCurrentHub().startTransaction(\n    {\n      metadata: { source: 'custom' },\n      ...context,\n    },\n    customSamplingContext,\n  );\n}\n\n\n//# sourceMappingURL=exports.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js\n/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase)\n * See https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\nfunction _optionalChain_optionalChain(ops) {\n  let lastAccessLHS = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    var op = ops[i] ;\n    var fn = ops[i + 1] ;\n    i += 2;\n    // by checking for loose equality to `null`, we catch both `null` and `undefined`\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      // really we're meaning to return `undefined` as an actual value here, but it saves bytes not to write it\n      return;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args) => (value ).call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\n\n// Sucrase version\n// function _optionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     var op = ops[i];\n//     var fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\n\n\n//# sourceMappingURL=_optionalChain.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/memo.js\n/**\n * Helper to decycle json objects\n */\nfunction memoBuilder() {\n  var hasWeakSet = typeof WeakSet === 'function';\n  var inner = hasWeakSet ? new WeakSet() : [];\n  function memoize(obj) {\n    if (hasWeakSet) {\n      if (inner.has(obj)) {\n        return true;\n      }\n      inner.add(obj);\n      return false;\n    }\n        for (let i = 0; i < inner.length; i++) {\n      var value = inner[i];\n      if (value === obj) {\n        return true;\n      }\n    }\n    inner.push(obj);\n    return false;\n  }\n\n  function unmemoize(obj) {\n    if (hasWeakSet) {\n      inner.delete(obj);\n    } else {\n      for (let i = 0; i < inner.length; i++) {\n        if (inner[i] === obj) {\n          inner.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n  return [memoize, unmemoize];\n}\n\n\n//# sourceMappingURL=memo.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/stacktrace.js\n\n\nvar STACKTRACE_LIMIT = 50;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nfunction createStackParser(...parsers) {\n  var sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack, skipFirst = 0) => {\n    var frames = [];\n\n    for (var line of stack.split('\\n').slice(skipFirst)) {\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      var cleanedLine = line.replace(/\\(error: (.*)\\)/, '$1');\n\n      for (var parser of sortedParsers) {\n        var frame = parser(cleanedLine);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nfunction stackParserFromStackParserOptions(stackParser) {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * @hidden\n */\nfunction stripSentryFramesAndReverse(stack) {\n  if (!stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n\n  var firstFrameFunction = localStack[0].function || '';\n  var lastFrameFunction = localStack[localStack.length - 1].function || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack\n    .slice(0, STACKTRACE_LIMIT)\n    .map(frame => ({\n      ...frame,\n      filename: frame.filename || localStack[0].filename,\n      function: frame.function || '?',\n    }))\n    .reverse();\n}\n\nvar defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nfunction getFunctionName(fn) {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\nfunction stacktrace_node(getModule) {\n  var FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  var FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n    return (line) => {\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line,\n      };\n    }\n\n    var lineMatch = line.match(FULL_MATCH);\n    if (!lineMatch) {\n      return undefined;\n    }\n\n    let object;\n    let method;\n    let functionName;\n    let typeName;\n    let methodName;\n\n    if (lineMatch[1]) {\n      functionName = lineMatch[1];\n\n      let methodStart = functionName.lastIndexOf('.');\n      if (functionName[methodStart - 1] === '.') {\n                methodStart--;\n      }\n\n      if (methodStart > 0) {\n        object = functionName.substr(0, methodStart);\n        method = functionName.substr(methodStart + 1);\n        var objectEnd = object.indexOf('.Module');\n        if (objectEnd > 0) {\n          functionName = functionName.substr(objectEnd + 1);\n          object = object.substr(0, objectEnd);\n        }\n      }\n      typeName = undefined;\n    }\n\n    if (method) {\n      typeName = object;\n      methodName = method;\n    }\n\n    if (method === '<anonymous>') {\n      methodName = undefined;\n      functionName = undefined;\n    }\n\n    if (functionName === undefined) {\n      methodName = methodName || '<anonymous>';\n      functionName = typeName ? `${typeName}.${methodName}` : methodName;\n    }\n\n    var filename = _optionalChain([lineMatch, 'access', _ => _[2], 'optionalAccess', _2 => _2.startsWith, 'call', _3 => _3('file://')]) ? lineMatch[2].substr(7) : lineMatch[2];\n    var isNative = lineMatch[5] === 'native';\n    var isInternal =\n      isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\\\') !== 1);\n\n    // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n    var in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n\n    return {\n      filename,\n      module: _optionalChain([getModule, 'optionalCall', _4 => _4(filename)]),\n      function: functionName,\n      lineno: parseInt(lineMatch[3], 10) || undefined,\n      colno: parseInt(lineMatch[4], 10) || undefined,\n      in_app,\n    };\n  };\n}\n\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */\nfunction nodeStackLineParser(getModule) {\n  return [90, stacktrace_node(getModule)];\n}\n\n\n//# sourceMappingURL=stacktrace.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/normalize.js\n\n\n\n\n\n/**\n * Recursively normalizes the given object.\n *\n * - Creates a copy to prevent original input mutation\n * - Skips non-enumerable properties\n * - When stringifying, calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format\n * - Translates known global objects/classes to a string representations\n * - Takes care of `Error` object serialization\n * - Optionally limits depth of final output\n * - Optionally limits number of properties/elements included in any single object/array\n *\n * @param input The object to be normalized.\n * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)\n * @param maxProperties The max number of elements or properties to be included in any single array or\n * object in the normallized output.\n * @returns A normalized version of the object, or `\"**non-serializable**\"` if any errors are thrown during normalization.\n */\nfunction normalize(input, depth = +Infinity, maxProperties = +Infinity) {\n  try {\n    // since we're at the outermost level, we don't provide a key\n    return visit('', input, depth, maxProperties);\n  } catch (err) {\n    return { ERROR: `**non-serializable** (${err})` };\n  }\n}\n\n/** JSDoc */\nfunction normalizeToSize(\n    object,\n  // Default Node.js REPL depth\n  depth = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize = 100 * 1024,\n) {\n  var normalized = normalize(object, depth);\n\n  if (jsonSize(normalized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return normalized ;\n}\n\n/**\n * Visits a node to perform normalization on it\n *\n * @param key The key corresponding to the given node\n * @param value The node to be visited\n * @param depth Optional number indicating the maximum recursion depth\n * @param maxProperties Optional maximum number of properties/elements included in any single object/array\n * @param memo Optional Memo class handling decycling\n */\nfunction visit(\n  key,\n  value,\n  depth = +Infinity,\n  maxProperties = +Infinity,\n  memo = memoBuilder(),\n) {\n  const [memoize, unmemoize] = memo;\n\n  // Get the simple cases out of the way first\n  if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !is_isNaN(value))) {\n    return value ;\n  }\n\n  var stringified = stringifyValue(key, value);\n\n  // Anything we could potentially dig into more (objects or arrays) will have come back as `\"[object XXXX]\"`.\n  // Everything else will have already been serialized, so if we don't see that pattern, we're done.\n  if (!stringified.startsWith('[object ')) {\n    return stringified;\n  }\n\n  // From here on, we can assert that `value` is either an object or an array.\n\n  // Do not normalize objects that we know have already been normalized. As a general rule, the\n  // \"__sentry_skip_normalization__\" property should only be used sparingly and only should only be set on objects that\n  // have already been normalized.\n  if ((value )['__sentry_skip_normalization__']) {\n    return value ;\n  }\n\n  // We're also done if we've reached the max depth\n  if (depth === 0) {\n    // At this point we know `serialized` is a string of the form `\"[object XXXX]\"`. Clean it up so it's just `\"[XXXX]\"`.\n    return stringified.replace('object ', '');\n  }\n\n  // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.\n  if (memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // If the value has a `toJSON` method, we call it to extract more information\n  var valueWithToJSON = value ;\n  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {\n    try {\n      var jsonValue = valueWithToJSON.toJSON();\n      // We need to normalize the return value of `.toJSON()` in case it has circular references\n      return visit('', jsonValue, depth - 1, maxProperties, memo);\n    } catch (err) {\n      // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)\n    }\n  }\n\n  // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse\n  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each\n  // property/entry, and keep track of the number of items we add to it.\n  var normalized = (Array.isArray(value) ? [] : {}) ;\n  let numAdded = 0;\n\n  // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant\n  // properties are non-enumerable and otherwise would get missed.\n  var visitable = convertToPlainObject(value );\n\n  for (var visitKey in visitable) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n      continue;\n    }\n\n    if (numAdded >= maxProperties) {\n      normalized[visitKey] = '[MaxProperties ~]';\n      break;\n    }\n\n    // Recursively visit all the child nodes\n    var visitValue = visitable[visitKey];\n    normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);\n\n    numAdded += 1;\n  }\n\n  // Once we've visited all the branches, remove the parent from memo storage\n  unmemoize(value);\n\n  // Return accumulated values\n  return normalized;\n}\n\n/**\n * Stringify the given value. Handles various known special values and types.\n *\n * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn\n * the number 1231 into \"[Object Number]\", nor on `null`, as it will throw.\n *\n * @param value The value to stringify\n * @returns A stringified representation of the given value\n */\nfunction stringifyValue(\n  key,\n  // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for\n  // our internal use, it'll do\n  value,\n) {\n  try {\n    if (key === 'domain' && value && typeof value === 'object' && (value )._events) {\n      return '[Domain]';\n    }\n\n    if (key === 'domainEmitter') {\n      return '[DomainEmitter]';\n    }\n\n    // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first\n    // which won't throw if they are not present.\n\n    if (typeof __webpack_require__.g !== 'undefined' && value === __webpack_require__.g) {\n      return '[Global]';\n    }\n\n        if (typeof window !== 'undefined' && value === window) {\n      return '[Window]';\n    }\n\n        if (typeof document !== 'undefined' && value === document) {\n      return '[Document]';\n    }\n\n    // React's SyntheticEvent thingy\n    if (isSyntheticEvent(value)) {\n      return '[SyntheticEvent]';\n    }\n\n    if (typeof value === 'number' && value !== value) {\n      return '[NaN]';\n    }\n\n    // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)\n    if (value === void 0) {\n      return '[undefined]';\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${getFunctionName(value)}]`;\n    }\n\n    if (typeof value === 'symbol') {\n      return `[${String(value)}]`;\n    }\n\n    // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion\n    if (typeof value === 'bigint') {\n      return `[BigInt: ${String(value)}]`;\n    }\n\n    // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting\n    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as\n    // `\"[object Object]\"`. If we instead look at the constructor's name (which is the same as the name of the class),\n    // we can make sure that only plain objects come out that way.\n    return `[object ${(Object.getPrototypeOf(value) ).constructor.name}]`;\n  } catch (err) {\n    return `**non-serializable** (${err})`;\n  }\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value) {\n    return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\nfunction jsonSize(value) {\n  return utf8Length(JSON.stringify(value));\n}\n\n\n//# sourceMappingURL=normalize.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/url.js\n/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nfunction parseUrl(url)\n\n {\n  if (!url) {\n    return {};\n  }\n\n  var match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  var query = match[6] || '';\n  var fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nfunction stripUrlQueryAndFragment(urlPath) {\n    return urlPath.split(/[\\?#]/, 1)[0];\n}\n\n/**\n * Returns number of URL segments of a passed string URL.\n */\nfunction getNumberOfUrlSegments(url) {\n  // split at '/' or at '\\/' to split regex urls correctly\n  return url.split(/\\\\?\\//).filter(s => s.length > 0 && s !== ',').length;\n}\n\n\n//# sourceMappingURL=url.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/requestdata.js\n\n\n\n\n\nvar DEFAULT_INCLUDES = {\n  ip: false,\n  request: true,\n  transaction: true,\n  user: true,\n};\nvar DEFAULT_REQUEST_INCLUDES = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];\nvar DEFAULT_USER_INCLUDES = ['id', 'username', 'email'];\n\n/**\n * Sets parameterized route as transaction name e.g.: `GET /users/:id`\n * Also adds more context data on the transaction from the request\n */\nfunction addRequestDataToTransaction(\n  transaction,\n  req,\n  deps,\n) {\n  if (!transaction) return;\n  if (!transaction.metadata.source || transaction.metadata.source === 'url') {\n    // Attempt to grab a parameterized route off of the request\n    transaction.setName(...extractPathForTransaction(req, { path: true, method: true }));\n  }\n  transaction.setData('url', req.originalUrl || req.url);\n  if (req.baseUrl) {\n    transaction.setData('baseUrl', req.baseUrl);\n  }\n  transaction.setData('query', extractQueryParams(req, deps));\n}\n\n/**\n * Extracts a complete and parameterized path from the request object and uses it to construct transaction name.\n * If the parameterized transaction name cannot be extracted, we fall back to the raw URL.\n *\n * Additionally, this function determines and returns the transaction name source\n *\n * eg. GET /mountpoint/user/:id\n *\n * @param req A request object\n * @param options What to include in the transaction name (method, path, or a custom route name to be\n *                used instead of the request's route)\n *\n * @returns A tuple of the fully constructed transaction name [0] and its source [1] (can be either 'route' or 'url')\n */\nfunction extractPathForTransaction(\n  req,\n  options = {},\n) {\n  var method = req.method && req.method.toUpperCase();\n\n  let path = '';\n  let source = 'url';\n\n  // Check to see if there's a parameterized route we can use (as there is in Express)\n  if (options.customRoute || req.route) {\n    path = options.customRoute || `${req.baseUrl || ''}${req.route && req.route.path}`;\n    source = 'route';\n  }\n\n  // Otherwise, just take the original URL\n  else if (req.originalUrl || req.url) {\n    path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');\n  }\n\n  let name = '';\n  if (options.method && method) {\n    name += method;\n  }\n  if (options.method && options.path) {\n    name += ' ';\n  }\n  if (options.path && path) {\n    name += path;\n  }\n\n  return [name, source];\n}\n\n/** JSDoc */\nfunction extractTransaction(req, type) {\n  switch (type) {\n    case 'path': {\n      return extractPathForTransaction(req, { path: true })[0];\n    }\n    case 'handler': {\n      return (req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name) || '<anonymous>';\n    }\n    case 'methodPath':\n    default: {\n      return extractPathForTransaction(req, { path: true, method: true })[0];\n    }\n  }\n}\n\n/** JSDoc */\nfunction extractUserData(\n  user\n\n,\n  keys,\n) {\n  var extractedUser = {};\n  var attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;\n\n  attributes.forEach(key => {\n    if (user && key in user) {\n      extractedUser[key] = user[key];\n    }\n  });\n\n  return extractedUser;\n}\n\n/**\n * Normalize data from the request object, accounting for framework differences.\n *\n * @param req The request object from which to extract data\n * @param options.include An optional array of keys to include in the normalized data. Defaults to\n * DEFAULT_REQUEST_INCLUDES if not provided.\n * @param options.deps Injected, platform-specific dependencies\n * @returns An object containing normalized request data\n */\nfunction extractRequestData(\n  req,\n  options\n\n,\n) {\n  const { include = DEFAULT_REQUEST_INCLUDES, deps } = options || {};\n  var requestData = {};\n\n  // headers:\n  //   node, express, koa, nextjs: req.headers\n  var headers = (req.headers || {}) \n\n;\n  // method:\n  //   node, express, koa, nextjs: req.method\n  var method = req.method;\n  // host:\n  //   express: req.hostname in > 4 and req.host in < 4\n  //   koa: req.host\n  //   node, nextjs: req.headers.host\n  var host = req.hostname || req.host || headers.host || '<no host>';\n  // protocol:\n  //   node, nextjs: <n/a>\n  //   express, koa: req.protocol\n  var protocol = req.protocol === 'https' || (req.socket && req.socket.encrypted) ? 'https' : 'http';\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  var originalUrl = req.originalUrl || req.url || '';\n  // absolute url\n  var absoluteUrl = `${protocol}://${host}${originalUrl}`;\n  include.forEach(key => {\n    switch (key) {\n      case 'headers': {\n        requestData.headers = headers;\n        break;\n      }\n      case 'method': {\n        requestData.method = method;\n        break;\n      }\n      case 'url': {\n        requestData.url = absoluteUrl;\n        break;\n      }\n      case 'cookies': {\n        // cookies:\n        //   node, express, koa: req.headers.cookie\n        //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies\n                requestData.cookies =\n          // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can\n          // come off in v8\n          req.cookies || (headers.cookie && deps && deps.cookie && deps.cookie.parse(headers.cookie)) || {};\n        break;\n      }\n      case 'query_string': {\n        // query string:\n        //   node: req.url (raw)\n        //   express, koa, nextjs: req.query\n                requestData.query_string = extractQueryParams(req, deps);\n        break;\n      }\n      case 'data': {\n        if (method === 'GET' || method === 'HEAD') {\n          break;\n        }\n        // body data:\n        //   express, koa, nextjs: req.body\n        //\n        //   when using node by itself, you have to read the incoming stream(see\n        //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know\n        //   where they're going to store the final result, so they'll have to capture this data themselves\n        if (req.body !== undefined) {\n          requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize(req.body));\n        }\n        break;\n      }\n      default: {\n        if ({}.hasOwnProperty.call(req, key)) {\n          requestData[key] = (req )[key];\n        }\n      }\n    }\n  });\n\n  return requestData;\n}\n\n/**\n * Options deciding what parts of the request to use when enhancing an event\n */\n\n/**\n * Add data from the given request to the given event\n *\n * @param event The event to which the request data will be added\n * @param req Request object\n * @param options.include Flags to control what data is included\n * @param options.deps Injected platform-specific dependencies\n * @hidden\n */\nfunction addRequestDataToEvent(\n  event,\n  req,\n  options,\n) {\n  var include = {\n    ...DEFAULT_INCLUDES,\n    ..._optionalChain_optionalChain([options, 'optionalAccess', _ => _.include]),\n  };\n\n  if (include.request) {\n    var extractedRequestData = Array.isArray(include.request)\n      ? extractRequestData(req, { include: include.request, deps: _optionalChain_optionalChain([options, 'optionalAccess', _2 => _2.deps]) })\n      : extractRequestData(req, { deps: _optionalChain_optionalChain([options, 'optionalAccess', _3 => _3.deps]) });\n\n    event.request = {\n      ...event.request,\n      ...extractedRequestData,\n    };\n  }\n\n  if (include.user) {\n    var extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};\n\n    if (Object.keys(extractedUser).length) {\n      event.user = {\n        ...event.user,\n        ...extractedUser,\n      };\n    }\n  }\n\n  // client ip:\n  //   node, nextjs: req.socket.remoteAddress\n  //   express, koa: req.ip\n  if (include.ip) {\n    var ip = req.ip || (req.socket && req.socket.remoteAddress);\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n\n  if (include.transaction && !event.transaction) {\n    // TODO do we even need this anymore?\n    // TODO make this work for nextjs\n    event.transaction = extractTransaction(req, include.transaction);\n  }\n\n  return event;\n}\n\nfunction extractQueryParams(\n  req,\n  deps,\n) {\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  let originalUrl = req.originalUrl || req.url || '';\n\n  if (!originalUrl) {\n    return;\n  }\n\n  // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n  // hostname on the beginning. Since the point here is just to grab the query string, it doesn't matter what we use.\n  if (originalUrl.startsWith('/')) {\n    originalUrl = `http://dogs.are.great${originalUrl}`;\n  }\n\n  return (\n    req.query ||\n    (typeof URL !== undefined && new URL(originalUrl).search.replace('?', '')) ||\n    // In Node 8, `URL` isn't in the global scope, so we have to use the built-in module from Node\n    (deps && deps.url && deps.url.parse(originalUrl).query) ||\n    undefined\n  );\n}\n\n\n//# sourceMappingURL=requestdata.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+nextjs@7.12.1_next@12.2.5+react@18.2.0/node_modules/@sentry/nextjs/esm/utils/_error.js\n\n\n\n\n/** Platform-agnostic version of `flush` */\nfunction flush(timeout) {\n  var client = hub_getCurrentHub().getClient();\n  return client ? client.flush(timeout) : Promise.resolve(false);\n}\n\n/**\n * Capture the exception passed by nextjs to the `_error` page, adding context data as appropriate.\n *\n * @param contextOrProps The data passed to either `getInitialProps` or `render` by nextjs\n */\nasync function captureUnderscoreErrorException(contextOrProps) {\n  const { req, res, err } = contextOrProps;\n\n  // 404s (and other 400-y friends) can trigger `_error`, but we don't want to send them to Sentry\n  var statusCode = (res && res.statusCode) || contextOrProps.statusCode;\n  if (statusCode && statusCode < 500) {\n    return Promise.resolve();\n  }\n\n  // In previous versions of the suggested `_error.js` page in which this function is meant to be used, there was a\n  // workaround for https://github.com/vercel/next.js/issues/8592 which involved an extra call to this function, in the\n  // custom error component's `render` method, just in case it hadn't been called by `getInitialProps`. Now that that\n  // issue has been fixed, the second call is unnecessary, but since it lives in user code rather than our code, users\n  // have to be the ones to get rid of it, and guaraneteedly, not all of them will. So, rather than capture the error\n  // twice, we just bail if we sense we're in that now-extraneous second call. (We can tell which function we're in\n  // because Nextjs passes `pathname` to `getInitialProps` but not to `render`.)\n  if (!contextOrProps.pathname) {\n    return Promise.resolve();\n  }\n\n  withScope(scope => {\n    scope.addEventProcessor(event => {\n      addExceptionMechanism(event, {\n        type: 'instrument',\n        handled: true,\n        data: {\n          function: '_error.getInitialProps',\n        },\n      });\n      return event;\n    });\n\n    if (req) {\n      scope.addEventProcessor(event => addRequestDataToEvent(event, req));\n    }\n\n    // If third-party libraries (or users themselves) throw something falsy, we want to capture it as a message (which\n    // is what passing a string to `captureException` will wind up doing)\n    captureException(err || `_error.js called with falsy error (${err})`);\n  });\n\n  // In case this is being run as part of a serverless function (as is the case with the server half of nextjs apps\n  // deployed to vercel), make sure the error gets sent to Sentry before the lambda exits.\n  await flush(2000);\n}\n\n\n//# sourceMappingURL=_error.js.map\n\n\n/***/ }),\n\n/***/ 557:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"R\": function() { return /* binding */ getGlobalObject; },\n/* harmony export */   \"Y\": function() { return /* binding */ getGlobalSingleton; }\n/* harmony export */ });\n/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7290);\n\n\n/** Internal */\n\nvar fallbackGlobalObject = {};\n\n/**\n * Safely get global scope object\n *\n * @returns Global scope object\n */\nfunction getGlobalObject() {\n  return (\n    (0,_node_js__WEBPACK_IMPORTED_MODULE_0__/* .isNodeEnv */ .KV)()\n      ? __webpack_require__.g\n      : typeof window !== 'undefined'       ? window       : typeof self !== 'undefined'\n      ? self\n      : fallbackGlobalObject\n  ) ;\n}\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value\n * @returns the singleton\n */\nfunction getGlobalSingleton(name, creator, obj) {\n  var global = (obj || getGlobalObject()) ;\n  var __SENTRY__ = (global.__SENTRY__ = global.__SENTRY__ || {});\n  var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());\n  return singleton;\n}\n\n\n//# sourceMappingURL=global.js.map\n\n\n/***/ }),\n\n/***/ 7290:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"l$\": function() { return /* binding */ dynamicRequire; },\n  \"KV\": function() { return /* binding */ isNodeEnv; }\n});\n\n// UNUSED EXPORTS: loadModule\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/env.js\n/*\n * This module exists for optimizations in the build process through rollup and terser.  We define some global\n * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these\n * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will\n * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to\n * `logger` and preventing node-related code from appearing in browser bundles.\n *\n * Attention:\n * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by\n * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)\n * having issues tree-shaking these constants across package boundaries.\n * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want\n * users to be able to shake away expressions that it guards.\n */\n\n/**\n * Figures out if we're building a browser bundle.\n *\n * @returns true if this is a browser bundle build.\n */\nfunction isBrowserBundle() {\n  return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;\n}\n\n\n//# sourceMappingURL=env.js.map\n\n;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+utils@7.12.1/node_modules/@sentry/utils/esm/node.js\n/* module decorator */ module = __webpack_require__.hmd(module);\n/* provided dependency */ var process = __webpack_require__(2032);\n\n\n/**\n * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,\n * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.\n */\n\n/**\n * Checks whether we're in the Node.js or Browser environment\n *\n * @returns Answer to given question\n */\nfunction isNodeEnv() {\n  // explicitly check for browser bundles as those can be optimized statically\n  // by terser/rollup.\n  return (\n    !isBrowserBundle() &&\n    Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'\n  );\n}\n\n/**\n * Requires a module which is protected against bundler minification.\n *\n * @param request The module path to resolve\n */\nfunction dynamicRequire(mod, request) {\n    return mod.require(request);\n}\n\n/**\n * Helper for dynamically loading module that should work with linked dependencies.\n * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`\n * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during\n * build time. `require.resolve` is also not available in any other way, so we cannot create,\n * a fake helper like we do with `dynamicRequire`.\n *\n * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.\n * That is to mimic the behavior of `require.resolve` exactly.\n *\n * @param moduleName module name to require\n * @returns possibly required module\n */\nfunction loadModule(moduleName) {\n  let mod;\n\n  try {\n    mod = dynamicRequire(module, moduleName);\n  } catch (e) {\n    // no-empty\n  }\n\n  try {\n    const { cwd } = dynamicRequire(module, 'process');\n    mod = dynamicRequire(module, `${cwd()}/node_modules/${moduleName}`) ;\n  } catch (e) {\n    // no-empty\n  }\n\n  return mod;\n}\n\n\n//# sourceMappingURL=node.js.map\n\n\n/***/ }),\n\n/***/ 7117:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ph\": function() { return /* binding */ timestampInSeconds; },\n/* harmony export */   \"yW\": function() { return /* binding */ dateTimestampInSeconds; }\n/* harmony export */ });\n/* unused harmony exports _browserPerformanceTimeOriginMode, browserPerformanceTimeOrigin, timestampWithMs, usingPerformanceAPI */\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(557);\n/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7290);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n/**\n * An object that can return the current timestamp in seconds since the UNIX epoch.\n */\n\n/**\n * A TimestampSource implementation for environments that do not support the Performance Web API natively.\n *\n * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier\n * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It\n * is more obvious to explain \"why does my span have negative duration\" than \"why my spans have zero duration\".\n */\nvar dateTimestampSource = {\n  nowSeconds: () => Date.now() / 1000,\n};\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction getBrowserPerformance() {\n  const { performance } = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();\n  if (!performance || !performance.now) {\n    return undefined;\n  }\n\n  // Replace performance.timeOrigin with our own timeOrigin based on Date.now().\n  //\n  // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +\n  // performance.now() gives a date arbitrarily in the past.\n  //\n  // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is\n  // undefined.\n  //\n  // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to\n  // interact with data coming out of performance entries.\n  //\n  // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that\n  // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes\n  // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have\n  // observed skews that can be as long as days, weeks or months.\n  //\n  // See https://github.com/getsentry/sentry-javascript/issues/2590.\n  //\n  // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload\n  // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation\n  // transactions of long-lived web pages.\n  var timeOrigin = Date.now() - performance.now();\n\n  return {\n    now: () => performance.now(),\n    timeOrigin,\n  };\n}\n\n/**\n * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't\n * implement the API.\n */\nfunction getNodePerformance() {\n  try {\n    var perfHooks = (0,_node_js__WEBPACK_IMPORTED_MODULE_1__/* .dynamicRequire */ .l$)(module, 'perf_hooks') ;\n    return perfHooks.performance;\n  } catch (_) {\n    return undefined;\n  }\n}\n\n/**\n * The Performance API implementation for the current platform, if available.\n */\nvar platformPerformance = (0,_node_js__WEBPACK_IMPORTED_MODULE_1__/* .isNodeEnv */ .KV)() ? getNodePerformance() : getBrowserPerformance();\n\nvar timestampSource =\n  platformPerformance === undefined\n    ? dateTimestampSource\n    : {\n        nowSeconds: () => (platformPerformance.timeOrigin + platformPerformance.now()) / 1000,\n      };\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n */\nvar dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * See `usingPerformanceAPI` to test whether the Performance API is used.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nvar timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);\n\n// Re-exported with an old name for backwards-compatibility.\nvar timestampWithMs = (/* unused pure expression or super */ null && (timestampInSeconds));\n\n/**\n * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.\n */\nvar usingPerformanceAPI = platformPerformance !== undefined;\n\n/**\n * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.\n */\nlet _browserPerformanceTimeOriginMode;\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nvar browserPerformanceTimeOrigin = (() => {\n  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n  // data as reliable if they are within a reasonable threshold of the current time.\n\n  const { performance } = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();\n  if (!performance || !performance.now) {\n    _browserPerformanceTimeOriginMode = 'none';\n    return undefined;\n  }\n\n  var threshold = 3600 * 1000;\n  var performanceNow = performance.now();\n  var dateNow = Date.now();\n\n  // if timeOrigin isn't available set delta to threshold so it isn't used\n  var timeOriginDelta = performance.timeOrigin\n    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)\n    : threshold;\n  var timeOriginIsReliable = timeOriginDelta < threshold;\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n    var navigationStart = performance.timing && performance.timing.navigationStart;\n  var hasNavigationStart = typeof navigationStart === 'number';\n  // if navigationStart isn't available set delta to threshold so it isn't used\n  var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n  var navigationStartIsReliable = navigationStartDelta < threshold;\n\n  if (timeOriginIsReliable || navigationStartIsReliable) {\n    // Use the more reliable time origin\n    if (timeOriginDelta <= navigationStartDelta) {\n      _browserPerformanceTimeOriginMode = 'timeOrigin';\n      return performance.timeOrigin;\n    } else {\n      _browserPerformanceTimeOriginMode = 'navigationStart';\n      return navigationStart;\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n  _browserPerformanceTimeOriginMode = 'dateNow';\n  return dateNow;\n})();\n\n\n//# sourceMappingURL=time.js.map\n\n\n/***/ }),\n\n/***/ 2032:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ref, ref1;\nmodule.exports = ((ref = __webpack_require__.g.process) == null ? void 0 : ref.env) && typeof ((ref1 = __webpack_require__.g.process) == null ? void 0 : ref1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(3329);\n\n//# sourceMappingURL=process.js.map\n\n/***/ }),\n\n/***/ 3329:\n/***/ (function(module) {\n\nvar __dirname = \"/\";\n(function(){var e={308:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(308);module.exports=r})();\n\n/***/ }),\n\n/***/ 7947:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(3691)\n\n\n/***/ }),\n\n/***/ 9452:\n/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Z\": function() { return /* binding */ _asyncToGenerator; }\n/* harmony export */ });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\n\n/***/ })\n\n}]);"],"names":["self","push","__unused_webpack_module","__webpack_exports__","__webpack_require__","d","captureUnderscoreErrorException","States","hasWeakSet","inner","esm_global","uuid4","global","R","crypto","msCrypto","randomUUID","replace","getRandomByte","getRandomValues","Uint8Array","Math","random","c","toString","time","CONSOLE_LEVELS","consoleSandbox","callback","originalConsole","console","wrappedLevels","forEach","level","originalWrappedFunc","__sentry_original__","Object","keys","makeLogger","enabled","logger","enable","disable","__SENTRY_DEBUG__","name","args","undefined","Y","node","objectToString","prototype","isBuiltin","wat","className","call","isString","isPlainObject","isThenable","Boolean","then","isInstanceOf","base","_e","SyncPromise","__init","_state","PENDING","_handlers","executor","__init2","__init3","__init4","__init5","__init6","_resolve","_reject","e","onfulfilled","onrejected","resolve","reject","result","reason","_executeHandlers","val","onfinally","isRejected","value","_setResult","RESOLVED","REJECTED","state","_value","cachedHandlers","slice","handler","_htmlElementAsString","el","keyAttrs","elem","out","classes","key","attr","i","tagName","toLowerCase","keyAttrPairs","length","filter","keyAttr","getAttribute","map","keyAttrPair","id","split","allowedAttrs","join","serializeEventTarget","target","isElement","Element","htmlTreeAsString","currentElem","MAX_TRAVERSE_HEIGHT","MAX_OUTPUT_LEN","height","len","separator","sepLength","nextStr","parentNode","reverse","_oO","getOwnProperties","obj","extractedProps","property","hasOwnProperty","_dropUndefinedKeys","inputValue","memoizationMap","memoVal","get","returnValue","set","Array","isArray","item","updateSession","session","context","user","ipAddress","ip_address","did","email","username","timestamp","ph","ignoreDuration","sid","init","started","duration","release","environment","userAgent","errors","status","Scope","constructor","_notifyingListeners","_scopeListeners","_eventProcessors","_breadcrumbs","_attachments","_user","_tags","_extra","_contexts","_sdkProcessingMetadata","clone","scope","newScope","_level","_span","_session","_transactionName","_fingerprint","_requestSession","_notifyScopeListeners","requestSession","tags","extras","extra","fingerprint","span","getSpan","transaction","captureContext","updatedScope","contexts","breadcrumb","maxBreadcrumbs","maxCrumbs","min","mergedBreadcrumb","yW","attachment","event","hint","trace","getTraceContext","transactionName","_applyFingerprint","breadcrumbs","sdkProcessingMetadata","_notifyEventProcessors","getGlobalEventProcessors","newData","processors","index","processor","log","final","maybeArray","concat","Hub","_stack","client","_version","getStackTop","bindClient","version","top","setupIntegrations","getScope","getStack","getClient","pop","pushScope","popScope","exception","eventId","_lastEventId","event_id","syntheticException","_withClient","captureException","originalException","message","captureMessage","type","captureEvent","beforeBreadcrumb","getOptions","finalBreadcrumb","addBreadcrumb","setUser","setTags","setExtras","setTag","setExtra","setContext","oldHub","makeMain","integration","getIntegration","warn","customSamplingContext","_callExtensionMethod","endSession","_sendSessionUpdate","layer","getSession","setSession","navigator","startingTime","getUser","toJSON","Date","toISOString","attrs","user_agent","Map","currentSession","options","sendDefaultPii","captureSession","method","sentry","carrier","__SENTRY__","extensions","apply","getMainCarrier","hub","registry","getHubFromCarrier","setHubOnCarrier","hub_getCurrentHub","hasHubOnCarrier","isOlderThan","KV","getHubFromActiveDomain","activeDomain","domain","active","registryHubTopStack","_Oo","_optionalChain_optionalChain","ops","lastAccessLHS","op","fn","defaultFunctionName","visit","depth","maxProperties","memo","WeakSet","has","add","delete","splice","memoize","unmemoize","includes","stringified","stringifyValue","startsWith","valueWithToJSON","jsonValue","err","normalized","numAdded","visitable","convertToPlainObject","isError","Error","stack","Event","newObj","currentTarget","CustomEvent","detail","visitKey","visitValue","_events","g","window","document","getFunctionName","String","getPrototypeOf","DEFAULT_INCLUDES","ip","request","DEFAULT_REQUEST_INCLUDES","DEFAULT_USER_INCLUDES","extractPathForTransaction","req","urlPath","toUpperCase","path","source","customRoute","route","baseUrl","originalUrl","url","extractRequestData","include","deps","requestData","headers","host","hostname","protocol","socket","encrypted","absoluteUrl","cookies","cookie","parse","query_string","extractQueryParams","body","data","JSON","stringify","normalize","input","ERROR","query","URL","search","contextOrProps","res","timeout","statusCode","pathname","Promise","withScope","addEventProcessor","addExceptionMechanism","newMechanism","firstException","values","currentMechanism","mechanism","handled","mergedData","function","addRequestDataToEvent","_","extractedRequestData","_2","_3","extractedUser","attributes","remoteAddress","extractTransaction","flush","getGlobalObject","getGlobalSingleton","_node_js__WEBPACK_IMPORTED_MODULE_0__","fallbackGlobalObject","creator","module","dynamicRequire","isNodeEnv","hmd","process","__SENTRY_BROWSER_BUNDLE__","mod","require","timestampInSeconds","dateTimestampInSeconds","_global_js__WEBPACK_IMPORTED_MODULE_0__","_node_js__WEBPACK_IMPORTED_MODULE_1__","dateTimestampSource","nowSeconds","now","platformPerformance","getNodePerformance","perfHooks","l$","performance","getBrowserPerformance","timeOrigin","timestampSource","bind","_browserPerformanceTimeOriginMode","performanceNow","dateNow","timeOriginDelta","abs","navigationStart","timing","navigationStartDelta","hasNavigationStart","__unused_webpack_exports","ref","ref1","exports","env","r","n","u","t","defaultSetTimout","defaultClearTimeout","runTimeout","setTimeout","clearTimeout","o","a","cleanUpNextTick","drainQueue","run","runClearTimeout","Item","fun","array","noop","nextTick","arguments","title","browser","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","__nccwpck_require__","ab","__dirname","__unused_webpack___webpack_module__","asyncGeneratorStep","gen","_next","_throw","arg","info","error","done","_asyncToGenerator"],"sourceRoot":""}